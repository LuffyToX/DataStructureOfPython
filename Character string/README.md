# 字符串

最基本的文字处理是文本处理，处理对象是结构简单的语言文本，即是某种（或某些）自然语言中的基本文字符号构成的序列。在计算机领域中，这样的基本文字符号称为 **字符**，符号的序列称为 **字符串**

讨论字符串及其数据结构的实现，以及字符串的处理，首先需要有一个确定的字符集。这里把字符作为一种抽象概念，字符集就是有穷的一组字符构成的集合。在实际工作中，人们经常考虑的是计算机领域广泛使用的某种标准字符集（如：ASCII 字符集 / Unicode 字符集），实际上，完全可以用任意一个数据元素的集合作为字符集

基于字符串处理的需要，要求字符集上有一种序关系，称为 **字符序**，即：在该字符集中的字符上定义一种顺序

+ 对于线性表，人们经常考虑的是元素与表的关系、元素的插入和删除
+ 而在考虑字符串时，经常需要把字符串作为一个整体使用和处理，考虑许多以整个串为对象的操作





## 字符串的抽象数据类型

这里首先有一种选择：

+ 将字符串定义为一种 **不变的** 数据类型；
+ 将字符串定义为一种 **可变的** 数据类型

```python
ADT String:
    String(self, seq)             # 基于字符串序列 seq，建立一个字符串
    is_empty(self)                # 判断此字符串是否为空串
    len(self)                     # 获取字符串的长度
    char(self, index)             # 获取字符串中下标为 index 的字符
    substr(self, a, b)            # 获取字符串中 [a, b) 子串
    match(self, string)           # 查找串 string 在本字符串中第一次出现时首字符在本字符串中的下标
    concat(self, string)          # 做出本字符串与另一字符串 string 的拼接串
    subst(self, str1, str2)       # 做出本字符串里的子串 str1 都替换为 str2 的结果串
```

最后两个操作可以实现为变动操作，实际修改本字符串；也可以实现为非变动操作，生成满足要求的另一个字符串





## 字符串的实现

字符串是字符的线性序列，可以采用线性表的各种实现技术实现，用 **顺序表/链表** 的形式表示，如：

+ 采用一体式顺序表形式，可用于表示创建时确定大小的字符串
+ 采用分离式顺序表形式，适合用于表示创建后需要动态改变大小的字符串



考虑字符串的表示时，有两个重要的方面需要确定：

+ 字符串内容的存储

  1. 把一个字符串的全部内容存储在一块连续存储区里；

  2. 把串中每个字符单独存入一块独立的存储块，并将这些块链接起来

+ 串结束的表示

  1. 用一个专门的数据域记录字符串长度；
  2. 用一个特殊编码表示串结束（C 语言的字符串采用了这种方式）



Python 标准类型 str 可以看作抽象的字符串概念的一个实现。str 是一个不变类型，其对象创建后内容和长度都不变化，但不同 str 对象的长度可能不同，因此需要在对象里记录字符串长度

在 Python 的官方实现里， str 对象采用 **一体式顺序表** 形式，实际上，在一个 str 对象的头部，除了记录字符串长度外，还记录了一些解释器用于管理对象的信息，它们是为系统内部操作服务的



有些操作需要构造新字符串，这类操作实现的基本模式包括两部分工作：

1. 先为欲构造的新字符串安排存储
2. 然后根据被操作串（和可能的参数串）以及操作确定的特定方式，在新存储块里做出所需的新串





## 子串匹配

对于字符串对象，最重要的操作之一是 **子串匹配**。这个操作不仅本身很重要，还是许多其他字符串操作的基础

> 子串匹配问题也被称为 **字符串匹配** / **字符串查找**



假设有两个串（$t_i$、$p_j$ 是字符）：
$$
t = t_0t_1t_2\cdot\cdot\cdot t_{n-1}
$$

$$
p = p_0p_1p_2\cdot\cdot\cdot p_{m-1}
$$

字符串匹配就是在 $t$ 中查找与 $p$ 相同的子串的操作，将 $t$ 称为 **目标串**、将 $p$  称为 **模式串**，且通常有 $m\ll n$



应用：

+ 在使用编辑器 / 字处理系统工作时，人们经常需要在文本中查找 单词 / 句子，在程序里找拼写错误的标识符等
+ 垃圾邮件过滤器通过检查邮件标题、发件人或内容中是否包含特定字符序列，评价其是否属于垃圾邮件
+ 搜索引擎的技术基础就是在互联网的网页中查找与各种检索需求（通常都是比较短的字符串）匹配的网页
+ 各种防病毒软件主要就是在各种文件里检索表征病毒的片段，也是串匹配
+ 分子生物学领域的发展更是将串匹配技术的应用推向高潮，全世界计算能力中相当大一部分是在做 DNA 匹配



粗看起来，字符串匹配是一个非常简单的问题，因为字符串是最简单数据（字符）的简单线性序列，其结构也最简单（简单的顺序结构），因此人们很容易想到最简单而且直接的算法。但实际情况是，这种直接而简单的算法多半不是高效算法，因为它们并没有很好地利用问题的内在性质

不同算法在处理不同的实际情况时，也可能有不同的表现，如：

+ 是用一个模式在很长的目标串里反复匹配；
+ 还是用一组（可能很多）模式在一个或一组目标串里确定是否有匹配



字符串匹配的基础是 **逐个比较字符**

从串匹配的角度看，两个字符的比较只需要得到相同或者不同的结论，是一个 **逻辑判断**：

+ 如果从目标串的某个位置 $i$ 开始，模式串里的每个字符都与目标串里的对应字符相同，就是找到了一个匹配

+ 如果在比较中遇到了一对不同的字符，那就是不匹配，说明模式串不能与目标串中从位置 $i$ 开始的子串匹配



对以下两点的不同处理策略，就形成了不同的串匹配算法：

+ 怎样选择开始比较的字符对
+ 发现了不匹配后下一步怎么做





## 串匹配：朴素匹配算法

最简单的朴素匹配算法采用最直观可行的策略：

+ 从左到右逐个匹配字符；
+ 发现不匹配时，转去考虑目标串里的下一个位置是否与模式串匹配



如下图，给出了一个示例：

+ 在状态 (0)：顺序比较，第一对字符不同，将模式串右移 1 位得到状态 (1)；
+ 在状态 (1)：顺序比较，第一对字符相同，但第二对字符不同，将模式串右移 1 位得到状态 (2)；
+ 在状态 (2)：顺序比较，第一对字符不同，将模式串右移 1 位得到状态 (3)；
+ 在状态 (3)：顺序比较，模式串的 5 个字符都与目标串字符相同，找到了一个匹配

![1](https://img-blog.csdnimg.cn/20200311205736119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjY0Nzc3,size_16,color_FFFFFF,t_70)

**图 朴素串匹配**



**朴素串匹配算法的实现**：

目标串 $t$ 的长度为 $n$、模式串 $p$ 长度为 $m$，且 $m\ll n$ 

$p_i$ 与 $t_j$ 匹配失败  ==>  模式串 $p$ 前 $i$ 个字符（$p_0\cdot\cdot\cdot p_{i-1}$）与目标串中 $t_j$ 前 $i$ 个字符（$t_{j-i}\cdot\cdot\cdot t_{j-1}$） 匹配成功 

显然，此时模式串首字符 $p_0$ 位于目标串的 $t_{j-i}$ 处 

```python
def nativeMatching(t, p):
    m, n = len(p), len(t)
    i, j = 0, 0
    while i<m and j<n:         # i == m 说明找到匹配
        if p[i] == t[j]:       # 字符相同，考虑下一对字符
            i, j = i+1, j+1
        else:                  # 字符不同，考虑 t 中的下一位置，且 p 回到初始位置
            i, j = 0, j-i+1
    if i == m:                 # 找到匹配，返回目标串中该子串的开始下标
        return j-i
    return -1                  # 未找到匹配
```



造成朴素串匹配算法低效的主要因素是执行中可能会出现回溯，匹配中遇到一对字符不同时：

+ 模式串 $p$ 将右移一个字符位置，随后的匹配回到模式串的开始（$i=0$）；
+ 目标串也回到上次匹配开始字符的下一个位置（$j = j-i+1$），从那里再次由 $p_0$ 开始比较字符



最坏的情况是每一趟比较都在模式串的最后遇到了字符不匹配的情况（每一趟做 $m$ 次比较），在这种匹配中总共需要做 $n-m+1$ 趟比较，总的比较次数为 $m\times (n-m+1)$，故该算法的时间复杂度为：$O(m\times n)$

> 模式串向右移动 $n-m$ 次，与目标串尾部对齐（匹配次数 = 移动次数 + 1），如：
>
> 0000001
>
> 001        
>
> 每趟匹配 $3$ 次，共匹配：$7-3+1 = 5$ 趟，总的比较次数：$3\times (7-3+1)$        



朴素匹配算法的效率低，根源在于把每次字符比较看作是完全独立的操作，完全没有利用字符串本身的特点（每个字符串都是特殊的、只有有穷多个字符等），也没有尽可能地利用前面已经做过的字符比较中得到的信息。从数学上看，这样做相当于认为目标串和模式串里的字符都是完全随机的量，而且有无穷多种可能取值，因此任意两个字符比较相互无关也不可借鉴。实际情况却并不是这样，字符串中的字符取值来自一个有穷集合，而且每个串都具有确定的有穷长度。特别是模式串，通常不太长，而且在匹配中被反复使用





## 串匹配：KMP 算法

如下图，给出了一个朴素匹配算法和 KMP 算法的比较过程：

朴素匹配算法：

+ 状态 (0) 的匹配进行到模式串中字符 c 时失败，此前有两次成功匹配，从中可知目标串前两个字符与模式串前两个字符相同
+ 由于模式串的前两个字符不同，与 b 匹配的目标串字符不可能与 a 匹配，因此状态 (1) 的匹配一定失败。朴素匹配算法未利用这种信息，做了无用功
+ 再看状态 (2)，这里前 4 个字符都匹配，最后匹配 c 时失败，由于模式串中第一个字符 a 与其后的两个字符不同，用 a 去匹配目标串里的 b、c 也一定失败，跳过这两个位置不会丢掉匹配点
+ 另一方面，模式串中下标为 3 的字符也是 a，它在状态 (2) 匹配成功，首字符 a 不必重做这一匹配
+ 朴素匹配算法没有考虑这些问题，总是一步步移位并从头比较

KMP 算法：

+ 在状态 (0) 匹配到第一个 c 失败时，由于已知前两个字符不同，KMP 算法直接把模式串移两个位置，模式串开头的 a 移到 c 匹配失败的位置，达到状态 (1)
+ 这次匹配直到模式串最后的 c 处失败，由于已知模式串 c 之前是 a，首字符也是 a，而且两个字符之间的字符与它们不同，不可能匹配，KMP 算法直接把模式串的 b 移到刚才匹配 c 失败的位置，达到状态 (2)
+ 接下来从模式串的 b 继续匹配，找到了一个成功匹配
+ 在这个过程中未出现重新检查目标串前面字符的情况（无回溯）

![1](https://img-blog.csdnimg.cn/20200311204949878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjY0Nzc3,size_16,color_FFFFFF,t_70)

**图 朴素匹配与KMP匹配过程**



### 问题分析

KMP 算法的基本想法是 **匹配中不回溯**

如果模式串里的 $p_i$ 匹配某个 $t_j$ 时失败了，就找到某个特定的 $k$（$0\leq k< i$），下一步用模式串中的字符 $p_k$ 与目标串里的  $t_j$  比较，也就是说，在匹配失败时把模式串前移若干位，然后用模式串里匹配失败字符之前的某个字符与目标串中匹配失败的字符比较。要实现这种策略，关键问题在于确定匹配失败时模式串如何前移，也就是说对模式串中的每个字符 $p_i$ 必须能找到相应的位置 $k$

KMP 算法设计中的关键认识是：在 $p_i$ 匹配失败时，所有的 $p_k(0\leq k <i)$ 都已经匹配成功。这也就是说，在目标串中 $t_j$ 之前的 $i$ 个字符（$t_{j-i}\cdot\cdot\cdot t_{j-1}$）也就是模式串 $p$ 的前 $i$ 个字符（ $p_0\cdot\cdot\cdot p_{i-1}$）。这说明，原本似乎应该根据目标串  $t$  中  $t_j$  之前已匹配的一段来决定模式串的前移位置，实际上只需根据模式串  $p$  本身的情况就可以决定了，完全可以在实际地与任何目标串匹配之前，通过对模式串本身的分析，解决好匹配失败时应该怎样前移的问题

可以得到如下结论：对  $p$  中的每个 $i$，都有与之对应的下标 $k$，而与被匹配的目标串无关，有可能通过对模式串 $p$ 的预分析，得到每个 $i$ 对应的 $k$。假设模式串 $p$ 的长度为 $m$，现在需要对每个 $i(0\leq i<m)$ 计算出对应的 $k$ 并将其保存起来，以便在匹配中使用。为此可以考虑用一个长为 $m$ 的表 $pnext$，用表元素 $pnext[i]$ 记录与 $i$ 对应的 $k$ 这里还有一种特殊情况：在一些 $p_i$ 的匹配失败时，有可能发现在用 $p_i$ 匹配之前做过的所有模式串字符与目标串字符的比较都没有实际利用价值。在这种情况下，下一步就应该从头开始，用 $p_0$ 匹配与 $t_{j+1}$ 比较。如果遇到这种特殊情况，就在 $pnext[i]$ 里存入 $-1$。显然，对任何一个模式串，都有 $pnext[0] = -1$



**KMP 算法的实现**：

```python
def KMPMatching(t, p, pnext):
    """ KMP 串匹配算法主函数 """

    i, j = 0, 0
    m, n = len(p), len(t)
    while i<m and j<n:                   # i == m 说明找到了匹配
        if i == -1 or p[i] == t[j]:      # 考虑 p 中下一个字符
            i, j = i+1, j+1
        else:                            # 匹配失败，考虑 pnext 表决定的下一字符
            i = pnext[i]
    if i == m:                           # 找到了匹配
        return j-i
    return -1
```

在整个循环中 $j$ 的值是递增的，但其 $+1$ 的总次数不会多于 $len(t)$。而且，$j$ 递增时，$i$ 的值也递增。而在 $if$ 的另一分支，语句 $i=pnext[i]$ 总使 $i$ 值减小，但 $if$ 的条件又保证 $i$ 的值不小于 $-1$（表元素值不会小于 $-1$，一旦等于 $-1$，下次迭代就会走另一分支），因此 $i=pnext[i]$ 的执行次数不会多于 $i$ 值递增的次数。故，虚幻次数不会多于 $O(n)$，即该算法的时间复杂度为 $O(n)$（$n$ 为目标串的长度 ）





### 构造 pnext 表

构造 $pnext$ 表的原则：

+ 作为下一个用于匹配的字符（$p_k$)，其前缀子串（$p_0\cdot\cdot\cdot p_{k-1}$）应该与匹配失败的字符（$p_i$）之前同样长度的子串（$p_{i-k}\cdot\cdot\cdot p_{i-1}$）相同
+ 如果 $p_i$ 的前缀子串中满足上述条件的位置 $k$ 不止一处，那么只能移动最短的距离（即：找最长前缀子串）



如下图所示：

目标串中位置 $j$ 之前的 $i$ 个字符也就是模式串的前 $i$ 个字符，即目标串中的子串  $t_{j-i}\cdot\cdot\cdot t_{j-1}$  就是  $p_0p_1\cdot\cdot\cdot p_{i-1}$ 现在需要找到一个位置  $k$，下次匹配用  $p_k$ 与前面匹配失败的  $t_j$ 比较，也就是把模式串移到  $p_k$ 与 $t_j$ 对准的位置

模式串里的子串  $p_0p_1\cdot\cdot\cdot p_{k-1}$ 应该与子串  $p_{i-k}\cdot\cdot\cdot p_{i-1}$ 匹配，而这两个子串分别为串 $p_0p_1\cdot\cdot\cdot p_{i-1}$ 的长度为 $k$ 的前缀和后缀，这样，确定  $k$  的问题就变成了确定模式串  $p_0p_1\cdot\cdot\cdot p_{i-1}$  的相等前后缀的长度。显然，$k$  越小表示移动越远，因此应该找的  $k$  是  $p_0p_1\cdot\cdot\cdot p_{i-1}$ 的最长相等前后缀（不包括 $p_0p_1\cdot\cdot\cdot p_{i-1}$ 但可以是空串），这样才能保证不跳过可能的匹配

如果  $p_0p_1\cdot\cdot\cdot p_{i-1}$ 的最长相等前后缀的长度为 $k(0\leq k<{i-1})$，在 $p_i\neq t_j$ 时，模式串就应该右移 $i-k$ 位，也就是说，应该把 $pnext[i]$ 设置为 $k$

![1](https://img-blog.csdnimg.cn/20200311204523952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjY0Nzc3,size_16,color_FFFFFF,t_70)

**图 pnext的分析与构造**



### 递推计算最长相等前后缀的长度

已知 $pnext[0]=-1$ 和直至 $pnext[i-1]$ 的已有值，且 $pnext[i-1]=k-1$ ，求 $pnext[i]$ 的算法：

1. 如果 $p_i=p_k$，那么 $p_0\cdot\cdot\cdot p_i$ 的最长相等前后缀应该 $+1$ （$k$），将 $i$ 值 $+1$ 后将该值记入 $pnext[i]$ 
2. 如果 $p_i\neq p_k$，就将 $k$ 设置为 $pnext[k]$ 的值（$k=pnext[k]$ 即：转去考虑前一个更短的保证匹配的前缀）
3. 如果 $k=-1$，那么 $p_0\cdot\cdot\cdot p_i$ 的最长相等前后缀的长度就是 0，将 $i$ 值 $+1$ 后，设置 $pnext[i]=0$ 



**pnext 表的构造**

```python
def genPnext(p):
    """ 生成针对 p 中个位置 i 的下一检查位置表，用于 KMP 算法 """

    i, k, m = 0, -1, len(p)
    pnext = [-1] * m                     # 初始数组元素全为 -1
    while i < m-1:                       # 生成下一个（即：i+1） pnext 元素值
        if k == -1 or p[i] == p[k]:
            i, k = i+1, k+1
            pnext[i] = k                 # 设置 pnext 元素
        else:
            k = pnext[k]                 # 退到更短的前缀
    return pnext
```



### pnext 表生成算法的改进

由于匹配失败时有 $p_i\neq t_j$，设 $pnext[i]=k$，如果发现 $p_i=p_k$，那么就一定有 $p_k\neq t_j$。在这种情况下，实际上模式串应该右移到 $pnext[k]$（而不仅仅右移到 $pnext[i]$），下一步应该用 $p_{pnext[k]}$ 与 $t_j$ 比较

```python
def genPnextEnhancement(p):
    """ 生成针对 p 中个位置 i 的下一检查位置表，用于 KMP 算法 """

    i, k, m = 0, -1, len(p)
    pnext = [-1] * m
    while i < m-1:                       # 生成下一个（即：i+1） pnext 元素值
        if k == -1 or p[i] == p[k]:
            i, k = i+1, k+1
            if p[i] == p[k]:
                pnext[i] = pnext[k]
            else:
                pnext[i] = k
        else:
            k = pnext[k]                 # 退到更短的前缀
    return pnext
```



### KMP 算法的时间复杂度及其他

显然，一次 KMP 算法的完整执行包括构造 $pnext$ 表和实际匹配，设模式串和目标串长度分别为 $m$ 和 $n$，KMP 算法的时间复杂度为 $O(m+n)$。由于多数情况 $m\ll n$，因此可以认为这个算法的时间复杂度为 $O(n)$ 

注意，许多场景中需要用一个模式串反复在一个或多个目标串里匹配，在这种情况下，构造模式串 $pnext$ 表的工作只须做一次，后面匹配中只须简单地反复使用，这是最适合 KMP 算法地场景

KMP 算法地一个重要优点是执行中不回溯，这种性质在一些实际应用中特别有价值，因为它支持一边读入一边匹配，不回头重读就不需要保存被匹配的串。在处理从外部（外存/网络等）获取的大量信息时，这种 算法非常合适

























































