

# 排序

排序就是整理数据的序列，使其中元素按照特定顺序排列的操作

> 在排序的过程中，序列里的数据元素保持不变，但其排列顺序可能改变



排序可以使数据的存储方式更具结构性，有利于对它们处理

+ 排好序的序列可以采用二分查找（效率高）
+ $Kruskal$ 算法中需要对图中的边按权值排序
+ 最佳二叉树生成算法需要所有的数据序列按关键码排序



一次具体排序总是针对某数据集合 $S$ 的元素组成的序列进行的，基于集合 $S$ 上的某种具体的序关系

> 一类常见的序关系是该集合上的全序



假设数据集合 $S$ 的元素上有一个序关系 $\leq$，一个排序算法 $sort$ 就是从 $S$ 的元素序列到 $S$ 的元素序列的映射

> 对 $S$ 的任意元素序列 $s$，$s'=sort(s)$ 是 $s$ 的一个排列，使得 $s'$ 中任意一对相邻元素 $e$ 和 $e'$，都有 $e\leq e'$



这里假设需要排序的是某种数据记录的序列 $R_0、R_1、\cdots、R_{n-1}$

- 每个记录里有一个或几个支持排序的关键码，这些关键码相对简单，存在易于判断的序关系，如：
  - 关键码是整数，序关系是整数的 “小于等于”
  - 关键码是字符串，序关系是字符串的字典序
- 在数据记录里还可以有任意多的其他成分，但它们与排序无关，可以忽略



基于关键码的排序，也就是根据记录中所考虑的那个关键码的序关系整理记录序列，使之成为按关键码排序的序列

+ 按关键码递增排序
+ 按关键码递减排序



排序方式

+ 内排序：待排序的记录全部保存在内存中
+ 外排序：待排序的记录保存在外存（磁盘、磁带等）



排序工作要求数据集合中存在一种可用的序，如果数据本身没有自然的序，也可以给它造出一种序

> 最典型的方法就是设计一种 $hash$ 函数，把数据集的元素映射到某个有序集



最优时间复杂度：基于关键码比较的排序问题，实现这一过程的任何算法都不可能优于 $O(nlogn)$



排序算法得两个性质：

+ 稳定性：稳定的排序算法能够维持序列中所有排序码相同记录得相对位置

+ 适应性：如果一个排序算法对接近有序的序列工作得更快，就称这种算法具有适应性





## 简单排序算法

简单排序算法的共同特点是：简单且最坏情况得时间复杂度高





### 插入排序

插入排序的基本操作方式是插入：不断地把一个个元素插入一个序列中，最终得到排序序列

> 作为插入操作的起点，需要有一个初始的已排序序列：
>
> + 无元素序列
> + 只有一个元素的序列



考虑连续表排序，希望尽可能少用辅助空间，最合适的方法是把正在构造的排序序列嵌入原来的表中

> 如此一来，排序中就只需要用几个简单变量，算法就可以做到只需要 $O(1)$ 的空间复杂度



**插入排序过程中的状态**

| 有序部分 | $d$  | 无序部分（$d$ 是无序部分的首元素） |
| -------- | ---- | ---------------------------------- |
|          | $i$  |                                    |

+ 在连续表的前段积累已排序序列，通过这个序列的不断生长，最终完成整个序列的排序工作
+ 在连续表的后段是尚未处理的元素，每次考虑这段元素的最左元素，即上图 $i$ 标识的元素





### 选择排序

在插入排序中，每次操作处理哪个记录并不重要，关键在于把被处理记录插入已排序序列中的正确位置，因此可以采用最简便的方式取记录，即按顺序提取。选择排序的想法与之对应，这里的基本操作是选择合适记录，只要严格按递增方式选出记录，简单地顺序排放就能完成排序工作（递减序列则反之）

+ 维护需要考虑的所有记录中最小的 $i$ 个记录的已排序序列
+ 每次从剩余未排序的记录中选取关键码最小的记录，将其放在已排序序列记录的后面，作为序列的第 $i+1$ 个记录，使已排序序列增长
+ 以空序列作为排序工作的开始，做到尚未排序的序列里只剩一个元素时（它必然为最大），只需直接将其放在已排序的记录之后，整个排序就完成了



#### 简单选择排序

顺序扫描序列中的元素，记住遇到的最小元素，一次扫描完毕就找到了一个最小元素，反复扫描就能完成排序工作；另一方面，选出了一个元素，原来的序列中就出现了一个空位，可以把这些空位集中起来存放排好序的序列



**选择排序中的状态**

| 有序部分 | $d$   | 无序部分（$d$ 是无序部分的首元素） |
| -------- | ----- | ---------------------------------- |
|          | $i+1$ |                                    |

+ 在连续表的前段积累一批递增的已经排好序的记录，而且它们都不大于任何一个未排序记录

+ 下一步从未排序记录中选出最小的记录，将其存放在已排序记录段的末尾（即上图 $i+1$）

  > 将选出的记录与 $i+1$ 处的记录互换

+ 这样，在只剩一个记录时，其关键码一定最大，工作即可结束





#### 堆排序

简单选择排序低效的原因在于：每次选择一个元素，都是从头开始做一遍完全的比较

> 在整个排序过程中做了很多重复比较工作



堆排序是一种高效的选择排序算法，该算法高效的主要原因在于：

+ 堆里积累了前面所做的比较中得到的信息，由于堆的结构特征，这种信息可以很自然地重复利用
+ 由于堆和顺序表的关系，一个堆和一个排序序列可以很方便地嵌入同一个顺序表，不需要任何辅助结构





### 交换排序（起泡排序）

一个序列中的记录没排好序，那么其中一定有逆序存在

+ 如果交换所发现的逆序记录对，得到的序列将更接近排序序列
+ 通过不断减少序列中的逆序，最终可以得到排序序列



起泡排序是一种典型的通过交换元素消除逆序实现排序的方法，其基本操作是比较相邻记录，发现相邻的逆序对时就交换它们，通过反复比较和交换，最终完成整个序列的排序工作

> 如果序列中每对相邻记录的顺序正确，整个序列就是一个排序序列



**起泡排序过程示例**

```bash
初始态：30  13  25  16  47  26  19  10

第一遍：13  25  16  30  26  19  10  47

第二遍：13  16  25  26  19  10  30  47

第三遍：13  16  25  19  10  26  30  47

第四遍：13  16  19  10  25  26  30  47

第五遍：13  16  10  19  25  26  30  47

第六遍：13  10  16  19  25  26  30  47

第七遍：10  13  16  19  25  26  30  47

```

+ 每一遍检查可以把一个最大元素交换到位，一些较大元素后移一段，可能移动很远

  > 经过 $n-1$ 遍扫描，一定能完成排序

+ 从左到右比较，导致小元素一次只左移一位，个别距离目标位置很远的小元素可能延误整个排序进程





## 快速排序

快速排序的实现中也采用了发现逆序和交换记录位置的方法，但算法中最基本的思想是划分，即按某种标准把考虑的记录划分为 “小记录” 和 “大记录”，并通过递归不断划分，最终得到一个排序的序列，其基本过程是：

+ 选择一种标准，把被排序序列中的记录按这种标准划分为大小两组

  > 从整体的角度来看，这两组记录的顺序已定，较小一组的记录应该排在前面

+ 采用同样的方式，将这两组记录继续递归地划分下去

+ 划分总是得到越来越小的分组，如此下去，直到每个记录组中最多包含一个记录时，整个序列的排序完成



**快速排序的表实现**

在实现排序工作时，人们希望尽可能在表的内部完成排序，尽可能少使用辅助空间。对快速排序，一个重要的设计目标是希望在原表的内部实现划分，也就是说，通过在表内移动记录将它们分为大小两段。根据后面工作需要，将小记录移到表的左部，大记录移到右部。这样，整个递归完成时表中记录就自然有序了

下一个问题是需要确定一种划分规则，现在考虑最简单的划分方式：取序列中第一个记录，以其关键码为标准划分其他记录，把关键码小的记录移到表的左边，关键码大的记录移到右边。划分完成后表中间将留下一个空位，这就是作为比较标准的记录的正确位置。把这个记录存入，其位置就固定了，在随后的操作中不需要改变

下一步是用同样的方式分别处理两段记录，并继续递归处理。当一个记录分段只有一个元素或没有元素时，其排序已完成。完成所有分段的排序，也就完成了整个表的排序

实际上，完全可以采用其他方法选择划分标准和移动记录，不同具体做法形成了顺序表上快速排序的不同实现



**划分的实现**

假设现在考虑一段记录，取出其中第一个记录作为标准，设其为 $R$。由于对大小记录的安排，划分中的一般状态如下图 $a)$ 所示（已知的小记录积累在左边，大记录积累在右边，中间是尚未检查的记录）

![图](https://img-blog.csdnimg.cn/20200328171543658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjY0Nzc3,size_16,color_FFFFFF,t_70)

为了完成划分，还需要利用好表中空位。取出记录 $R$ 使表左边出现了一个空位，如图  $b)$，这时从右端开始检查，就可以利用这个空位，把发现的第一个小记录移到左边。这一迁移操作也导致右边留下一个空位，如图 $c)$，可供存放在左边发现的一个大记录

算法中利用两个下标变量 $i$ 和 $j$，其初值分别是序列中第一个和最后一个记录的位置。在划分过程中，他们的值交替地作为空位和下一个被检查记录的下标。然后取出第一个记录 $R$，设其关键码为 $K$，作为划分标准

+ 交替进行下面两套操作：

  + 状态如图 $b)$ 所示，从右向左逐个检查 $j$ 一边的记录，检查中 $j$ 不断减一，直到找到一个关键码小于 $K$ 的记录。注意，移动记录后位置 $j$ 变成空位，$i$ 加一后指向下一需要检查的记录
  + 状态如图 $c)$ 所示，从左向右逐个检查 $i$ 一边的记录，检查中 $i$ 不断加一，直到找到一个关键码大于 $K$ 的记录，并将其存入 $j$ 所指空位。移动记录又得到图 $b)$ 所示的状态，转做上面的操作

+ 重复交替进行上述两套操作，直到 $i$ 不再小于 $j$ 为止

  > 由于第一种操作中 $j$ 不断减小，第二种操作中 $i$ 不断增大，故划分一定能完成

+ 划分结束时 $i$ 与 $j$ 的值相等，指向当时表中的空位。将记录 $R$ 存入该空位，一次划分完成

+ 一次划分完成后对两边的子序列按同样的方式做递归处理





## 归并排序

归并是一种典型的序列操作，其工作是把两个或更多有序序列合并为一个有序序列。基于归并的思想也可以实现排序，称为归并排序。简单二路归并排序（每次操作都是把两个有序序列合并为一个有序序列）基本方法如下：

+ 初始时，把待排序序列中的 $n$ 个记录看成 $n$ 个有序子序列，每个子序列的长度均为 $1$

  > 一个记录的序列总是排好序的

+ 把当时序列组里的有序子序列两两归并，完成一遍后序列组里的排序序列个数减半，每个子序列的长度加倍

+ 对加长的子序列重复上面的操作，最终得到一个长度为 $n$ 的有序序列



**简单二路归并排序示例**

```bash
初始态：(25)  (67)  (54)  (33)  (20)  (78)  (65)  (49)  (17)  (56)  (44)

第一遍：(25  67)    (33  54)    (20  78)    (49  65)    (17  56)    (44)

第二遍：(25  33  54  67)        (20  49  65  78)        (17  44  56)

第三遍：(20  25  33  49  54  65  67  78)                (17  44  56)

第四遍：(17  20  25  33  44  49  54  56  65  67  78)
```



**归并算法的设计问题**

对于归并排序，这里不考虑原地排序（实现比较复杂），而是另外开辟了一片同样大小的存储区，也就是建立了另一个同样大小的表，把一遍归并的结果放在那里。在一遍归并做完后，在保存归并结果的新表里存储着加倍长度的有序序列，而且原来的表已经闲置了，在这种情况下，可以考虑调换两个表的角色，在原表中累积下一遍归并的结果。这样来来回回做几遍，就能完成整个排序工作





## Python 的 list 排序

内置的排序函数 $sort$ 可以对任何可迭代对象排序，得到一个排序的表；另外，表 $list$ 类也有一个 $sort$ 方法

> 两者共享同一个排序算法，这是一种混成式的排序算法，称为 $Timsort$（蒂姆排序）



蒂姆排序是一种基于归并技术的稳定排序算法，结合使用了归并排序和插入排序技术

+ 最坏时间复杂度是 $O(nlogn)$ 
+ 该算法具有适应性，在被排序的数组元素接近好序的情况下，它的时间复杂度可能达到 $O(n)$ 
+ 在最坏的情况下需要 $n/2$ 的工作空间，因此其空间复杂度为 $O(n)$
+ 如果情况有利，它只需要很少的临时存储空间 



蒂姆排序比较适合许多实际应用中常见的情况，特别是被排序的数据序列分段有序或者基本有序，但其中也有些非有序元素的情况。人们通过许多试验，结论是蒂姆排序在平均性能上超过快速排序，是目前实际表现最好的排序算法，虽然它未能从理论上克服归并排序 $O(n)$ 空间开销的弱点，但实际中经常不需要很大的工作空间



蒂姆排序克服了归并排序没有适应性的缺陷，又保持了其稳定性的特征，并尽可能利用实际数据的情况

+ 考察待排序序列中非严格单调上升或严格单调下降的片段，反转其中的严格单调下降片段

+ 采用插入排序，对连续出现的几个特别短的上升序列排序，使整个序列变成一系列非严格单调上升的记录片段

  > 每个片段都长于某个特定值

+ 通过归并产生更长的排序片段，控制这一归并过程，保证片段的长度尽可能均匀

  > 归并中采用一些策略，尽可能地减少临时空间的使用

+ 通过反复归并，最终得到排序序列





## 几种排序算法的比较

| 排序算法     | 最坏时间复杂度 | 平均时间复杂度 | 最优时间复杂度 | 空间复杂度 | 稳定性 | 适应性 |
| ------------ | -------------- | -------------- | -------------- | ---------- | ------ | ------ |
| 插入排序     | $O(n^2)$       | $O(n^2)$       | $O(n)$         | $O(1)$     | √      | √      |
| 简单选择排序 | $O(n^2)$       | $O(n^2)$       | $O(n^2) $      | $O(1)$     | ×      | ×      |
| 堆排序       | $O(nlogn)$     | $O(nlogn)$     | $O(nlogn)$     | $O(1)$     | ×      | ×      |
| 起泡排序     | $O(n^2)$       | $O(n^2)$       | $O(n)$         | $O(1)$     | √      | √      |
| 快速排序     | $O(n^2)$       | $O(nlogn)$     | $O(nlogn)$     | $O(logn)$  | ×      | ×      |
| 归并排序     | $O(nlogn)$     | $O(nlogn)$     | $O(nlogn)$     | $O(n)$     | √      | ×      |
| 蒂姆排序     | $O(nlogn)$     | $O(nlogn)$     | $O(n)$         | $O(n)$     | √      | √      |

