# 队列

队列也是一种容器，可存入元素、访问元素和删除元素

队列中没有位置的概念，只支持默认方式的元素存入和取出。其特点就是保证在任何时刻可访问和删除的元素都是在此前最早存入队列而至今未删除的那个元素，因此队列是 **先进先出（FIFO）** 的结构





## 队列抽象数据类型

```python
ADT Queue:
    Queue(self)                      # 创建空队列
    is_empty(self)                   # 判断队列是否为空 Ture/False
    enqueue(self, elem)              # 将元素 elem 加入队列（队尾，入队）
    dequeue(self)                    # 删除队头元素（出队）
    peek(self)                       # 查看队头元素（不删除）
```





## 链接队列

采用线性表技术实现队列，就是利用元素位置的顺序表示入队时间的先后关系。队列操作要求先进先出，从线性顺序看，这就要求在表的两端进行操作，不像栈那样在表的一端操作，实现起来也稍微麻烦一些

由于需要在链接表的两端操作：表尾入队、表头出队，而最简单的单链表只支持首端高效操作，在另一端操作需要  $O(n)$ 时间，不适合不适合作为队列的实现基础，因此，添加尾指针，使其尾端插入操作也为 $O(1)$





## 顺序队列

### 基于顺序表实现队列的困难

首先假设用顺序表的尾端插入实现 $enqueue$ 操作，根据队列的性质，出队操作应该在表的首端进行。为了维护顺序表的完整性（表元素在表前端连续存放），出队操作取出当时的首元素后，就需要把表中其余元素全部前移，这样将得到一个 $O(n)$ 时间的操作（$Python$ 里 $list.pop(0)$ 操作就是如此）。反过来实现的情况与此类似：从尾端弹出元素是 $O(1)$ 时间操作，但从首端插入是 $O(n)$ 时间操作。两种设计都无法排除 $O(n)$ 操作，因此都不理想



另一种可能是在队首元素出队后表中的元素不前移，但记住新队头/队尾的位置。这一设计也有问题：经过一系列的入队和出队操作，队头/队尾位置变量的值将 随着操作移动。从操作效率看，每个操作都能在 $O(1)$ 时间完成。但另一方面，表中元素序列却好像随着操作向表尾方向移动，表前端留下越来越多的空位

表元素存储区大小是固定的，经过反复的入队和出队操作，一定会在某次入队时出现队尾溢出（表满）的情况。而在出现这种溢出时，表前部通常会有些空位，因此这是一种 “假性溢出”，并不是真的用完了整个元素区。加入元素存储区能自动增长（如：$Python$ 的 $list$），随着操作进行，表前端就会留下越来越大的空区。而且这片空区永远不会用到，完全浪费，显然不应该让程序出现这种情况





### 循环顺序表

循环顺序队列：把一定大小的顺序表看作一种环形结构，认为其最后存储位置之后是最前的位置，形成一个环形

+ 在队列使用中，顺序表的开始位置并不改变
+ 队头变量 $q.head$ 记录当前队列里第一个元素的位置
+ 队尾变量 $q.rear$ 记录当前队列里最后元素之后的第一个空位
+ 队列元素保存在顺序表的一段连续单元里，即：[$q.head, q.rear$)

初始时队列为空，应该让 $q.head$ 和 $q.rear$ 取相同的值，表示顺序表里一个空段，具体取值无关紧要

出队和入队操作分别需要更新变量 $q.head$ 和 $q.rear$，正确的操作如下：

```python
q.head = (q.head + 1) % q.len        # 出队
q.rear = (q.rear + 1) % q.len        # 入队

q.head == q.rear                     # 队空
q.head == (q.rear + 1) % q.len       # 队满（采用这种方法将在表里留下一个不用的空位）
```





### 队列的 list 实现



























