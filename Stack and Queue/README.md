# 栈与队列

在常用的数据结构中，有一批结构被称为 **容器**

一个容器结构里总包含一组其他类型的数据对象，称为其元素，该容器支持对这些元素的存储、管理和使用。一个容器具有相同的性质，支持同一组操作，可以被定义为一个抽象数据类型。作为容器数据结构，它们都保证存入的元素被保存在容器里，尚未明确删除的元素总可以访问，而取出并删除的元素就不再存在于容器中了

栈和队列都是保存数据元素的容器，这就意味着可以把元素存入其中，或者从中取出元素使用

+ **查看**：只是取得元素的有关信息
+ **弹出**：取得元素的同时将其从容器中删除

栈和队列主要用于在计算过程中保存临时数据，这些数据是计算中发现 / 产生的，在后面的计算中可能需要使用它们。在计算中这种情况很常见：工作中产生的中间数据暂时不用或者用不完，就有必要把当时不能立刻用掉的数据存起来。如果可能生成的数据项数在编程时可以确定，问题比较简单，可以设置几个变量作为临时存储；但如果需要存储的数据项数不能事先确定，就必须采用更复杂的机制存储和管理，这样的存储机制称为缓存。栈和队列就是使用最多的缓存，也是最简单的缓存结构，它们只支持数据项的存储和访问，不支持数据项之间的任何关系

+ 栈是保证元素后进先出关系的结构，简称 **LIFO**
+ 队列是保证元素先进先出关系的结构，简称 **FIFO**

栈和队列的使用环境：

+ 计算过程分为一些顺序进行的步骤（任何复杂一点的计算都是这样）
+ 计算中执行的某些步骤会不断产生一些后面可能需要的中间数据
+ 产生的数据中有些不能立即使用，但又需要在将来使用
+ 需要保存的数据的项数不能事先确定

****





# 栈

栈是一种容器，可存入数据元素、访问元素、删除元素等。存入栈中的元素之间相互没有任何具体关系，只有到来的时间先后顺序，在这里没有元素的位置、先后顺序的概念。栈的基本性质保证，在任何时刻可以访问、删除的元素都是在此之前最后存入的那个元素（栈顶元素）。因此，栈确定了一种默认元素访问顺序，访问时无需其他信息





## 栈抽象数据类型

```python
ADT Stack:
    Stack(self)                         # 创建空栈
    is_empty(self)                      # 判断栈是否为空（True / False）
    push(self, elem)                    # 将元素 elem 加入栈（压栈）
    pop(self)                           # 删除栈顶元素并返回（出栈）
    top(self)                           # 取得栈顶元素
```



栈可以实现为（看作）在一端进行 插入 / 删除 的线性表。在表实现中，执行插入和删除操作的一端称为 **栈顶**，另一端称为 **栈底**。用线性表的技术实现栈时，操作只在表的一端进行，不涉及另一端，更不涉及表的中间部分

- 对于顺序表，后端插入和删除操作是 $O(1)$ 操作，应该用这一端（表尾）作为栈顶
- 对于链接表，前端插入和删除操作是 $O(1)$ 操作，应该用这一端（表头）作为栈顶 





## 顺序栈

采用顺序表实现栈，首先会遇到实现顺序表时提出的各种问题，如：是采用简单顺序表实现，还是采用动态顺序表

- 一体式顺序表：可能出现栈满的情况，继续压入元素就会溢出，应该检查和处理
- 分离式顺序表：栈满时可以置换一个更大的存储区，这种情况下又会出现存储区的置换策略问题



$Python$ 的 $list$ 及其操作实际上提供了与栈的使用方式有关的功能，可以直接作为栈来使用

- 建立空栈：创建空表 $list()$
- 判空栈：检查是否为空表
- $list$ 采用动态顺序表技术，作为栈的表不会满
- 压栈：$lst.append()$
- 访问栈顶元素：$lst[-1]$
- 出栈：$lst.pop()$



把  $list$  当作栈使用，完全可以满足应用的需要。但是这样建立的对象还是 $list$，提供了 $list$ 类型的所有操作，特别是提供了一大批栈结构原本不应该支持的操作，威胁栈使用的安全性。另外，这样的栈不是一个独立的类型，因此没有独立类型的所有重要性质。为了概念更清晰，实现安全，操作名也更易理解，可以考虑基于顺序表定义一个栈类，使之成为一个独立的类型，把 $Python$ 的 $list$ 隐藏在这个类的内部，作为其实现基础





## 链栈

链栈的基础结构就是单链表

由于 $list$ 可以自动扩大存储区，前面基于顺序表的栈类不会出现栈满的情况，因此应该能满足绝大部分的实际需要。在这种情况下，为什么还需要基于链表的栈实现？对这个问题的回答主要考虑顺序表的两个特点：

- 扩大存储区需要做一次高代价操作
- 顺序表需要完整的大块存储区

采用链接技术，在这两个问题上都有优势





## 栈的应用

栈是算法和程序里最常用的辅助结构，基本用途基于两个方面：

- 使用栈可以很方便地保存和取用信息，因此它常被作为算法或程序里的辅助存储结构，临时保存信息
- 栈具有后进先出的性质，利用这种性质可以保证特定的存取顺序，对于许多实际应用这种性质非常重要





### 示例 1：颠倒序列

栈可以用于颠倒一组元素的顺序：只需把元素按原来的顺序全部压栈，再顺序出栈，就能得到反序后的序列

```python
# 时间复杂度为 O(n)

ss = SStack()
lst2 = list()
for x in lst1:
    ss.push(x)
while not ss.is_empty():
    lst2.append(ss.pop_())
```

如果允许压栈和出栈操作任意交错，通过不同的压栈出栈操作序列，可以得到不同的元素序列。但请注意，这种做法并不能得到原序列的任意排列，结果序列有一定的规律性





### 示例2：括号匹配问题

检查括号配对的原则：

- 在扫描正文过程中，遇到闭括号应该与此前最近遇到且尚未获得匹配的开括号配对
- 如果最近未匹配开括号与当前闭括号不配对 / 找不到这样的开括号，就是匹配失败



由于存在多种不同的括号对，每种括号都可能出现任意多次，而且还可能嵌套，为了检查是否匹配，扫描中必须保存遇到的开括号；由于写程序时无法预知要处理的正文里会有多少需要保存，因此不能用固定数目的变量保存，必须用缓存结构；由于括号的出现可能嵌套，需要逐对匹配：当前括号应该与前面最近的尚未配对的开括号匹配，这说明，需要存储的开括号的使用原则是后存入者先使用，即 **LIFO** 原则；如果一个开括号已配对，就应该删除

1. 顺序扫描被检查正文（一个字符串）里的一个个字符
2. 检查中跳过无关字符（所有非括号字符都与当前处理无关）
3. 遇到开括号时，就将其压栈
4. 遇到闭括号时，弹出当前的栈顶元素并与之匹配
5. 如果匹配成功则继续，发现不匹配时检查以失败结束





### 示例3：表达式的表示、计算和变换

**中缀表达式**：二元运算符写在其两个运算对象中间（最常见的表达形式）

> 它不足以表示所有可能的运算顺序，需要通过辅助记号、约定和辅助描述机制
>
> - 必须引进括号的概念，规定括号里的运算先做，以便于人们直接说明一些计算的特定顺序
> - 给各种运算符规定了不同的优先级，多个运算符相继出现时，优先级高的运算先做
> - 有了这些还不够，还要规定具有相同优先级的运算符相继出现时的计算顺序

**前缀表达式**：所有运算符都写在他们的运算对象之前，亦称波兰表达式

**后缀表达式**：所有运算符都写在他们的运算对象之后，亦称逆波兰表达式（特别适合计算机处理）

下面是同一算术表达式的等价表示形式：

- 中缀形式：`(3-5) * (6 + 17*4) / 3​`
- 前缀形式：`/ * - 3 5 + 6 * 17 4 3​`
- 后缀形式：`3 5 - 6 17 4 * + * 3 /`





#### 后缀表达式的计算

根据后缀表达式的计算规则，计算过程应该是顺序检查表达式里的一个个项，分两种情况：

- 遇到运算对象：记录，以备后面使用
- 遇到运算符：根据其元数，取得前面最近遇到的几个运算对象/已完成运算的结果，计算并保存结果



在这里又遇到了需要记录信息以备将来使用的问题，必须用一个缓存结构：

- 需要记录的是已经掌握的数据，无论这些数据是直接由外部得到，还是计算出来，都需要缓存（尚不可用）
- 每次处理运算符，应使用的是此前最后记录的几个结果（具体项数应该根据运算符的元数确定）

显然，这里的情况是后保存先使用（**LIFO**），应该用栈作为缓存结构





#### 中缀表达式到后缀表达式的转换

中缀形式：`(3-5) * (6 + 17*4) / 3`

后缀形式：`3 5 - 6 17 4 * + * 3 /`

对照两个表达式，可以看到转换中需要考虑的一些基本情况：

- 在扫描中缀表达式的过程中，如果遇到运算对象，就应该直接将其送出，作为后缀表达式的一个项
- 把运算符放入后缀表达式也就是要求运算，需要仔细控制送出的时机



在考虑运算符在后缀表达式里的出现位置时，必须处理好中缀表达式的优先级和结合性问题：

- 扫描中遇到一个运算符时不能将其送出，只有看到下一运算符的优先级不高于本运算符时，才能够送出
- 可以看到，在这个过程中，总要拿当前运算符与前面最近的且尚未送走的运算符比较，而且可能删除前面的运算符，这也是后保存的信息先使用（与前面保存的最后一个运算符比较，而且还可能用掉它）。另一方面，处理中需要记录的运算符个数也无法事先确定，因此应该用一个栈保存尚未处理的运算符
- 另一方面，转换中还需要处理括号的问题。表达式里的括号是配对的，左括号标明了一个应该优先计算的子表达式的起点，需要记录；右括号说明应该优先计算的子表达式到此为止。因此，在遇到右括号时，需要逐个弹出栈里的运算符（排在后面的必定具有更高优先级），直至遇到左括号时也将其弹出
- 此外，在扫描完整个中缀表达式时，栈里可能还剩下一些运算符。他们的计算都应该进行，也就是说，应该把它们一一弹出送到后缀表达式





#### 中缀表达式的求值

直接求中缀表达式的值，需要统一考虑以下问题：

- 运算符的优先级
- 括号的作用
- 根据扫描表达式过程中的情况，确定完成各个运算的时机
- 在需要做某个运算时，能找到正确的运算对象



由于现在要计算中缀表达式，扫描中遇到运算对象时不能输出，而应该临时保存起来，在需要用的时候能比较容易地找到它们。根据后缀表达式的计算规则：每当需要执行一个运算时，对应的运算对象应该是前面最近遇到的运算对象或最近计算得到的结果。在后缀表达式计算器里用一个栈保存这些数据，现在可以模拟它，另外引进一个数据栈，保存运算对象和计算得到的中间结果

1. 扫描中遇到运算对象将其压入数据栈
2. 遇到运算符和括号时，按照前面转换算法中的方式，分几种情况处理：
   - 左括号：压入运算符栈
   - 右括号：弹出运算符完成计算，直至弹出对应左括号
   - 其他运算符：按照前面做法，基于优先级处理
3. 确定了应该应用一个运算符时：
   - 其运算对象就是数据栈顶的两个项
   - 完成计算得到的结果还需要压进数据栈
4. 整个表达式处理完后，逐项弹出运算符栈剩下的运算符并完成计算





****

# 队列

队列也是一种容器，可存入元素、访问元素和删除元素。队列中没有位置的概念，只支持默认方式的元素存入和取出，其特点就是保证在任何时刻可访问和删除的元素都是在此前最早存入队列而至今未删除的那个元素，因此队列是 **先进先出（FIFO）** 的结构





## 队列抽象数据类型

```python
ADT Queue:
    Queue(self)                      # 创建空队列
    is_empty(self)                   # 判断队列是否为空 Ture/False
    enqueue(self, elem)              # 将元素 elem 加入队列（队尾，入队）
    dequeue(self)                    # 删除队头元素（出队）
    peek(self)                       # 查看队头元素（不删除）
```





## 链接队列

采用线性表技术实现队列，就是利用元素位置的顺序表示入队时间的先后关系。队列操作要求先进先出，从线性顺序看，这就要求在表的两端进行操作，不像栈那样在表的一端操作，实现起来也稍微麻烦一些

由于需要在链接表的两端操作：表尾入队、表头出队，而最简单的单链表只支持首端高效操作，在另一端操作需要  $O(n)$ 时间，不适合作为队列的实现基础，因此，添加尾指针，使其尾端插入操作也为 $O(1)$





## 顺序队列

### 基于顺序表实现队列的困难

首先，假设用顺序表的尾端插入实现  $enqueue$  操作，则  $dequeue$ 操作应该在表的首端进行。为了维护顺序表的完整性（表元素在表前端连续存放），出队操作取出首元素后，就需要把表中其余元素全部前移，这样将得到一个 $O(n)$ 时间的操作（$Python$ 里 $list.pop(0)$ 操作就是如此），反过来也如此



其次，在队首元素出队后表中的元素不前移，但记住新队头和队尾的位置，但经过一系列的 $enqueue$ 和 $dequeue$ ，队头和队尾位置变量的值将随着操作移动。从操作效率看，每个操作都能在 $O(1)$ 时间完成，但另一方面，表中元素序列却好像随着操作向表尾方向移动，表前端留下越来越多的空位。表元素存储区大小是固定的，经过反复的入队和出队操作，一定会在某次入队时出现队尾溢出（表满）的情况。而在出现这种溢出时，表前部通常会有些空位，因此这是一种 “假性溢出”，并不是真的用完了整个元素区。加入元素存储区能自动增长（如：$Python$ 的 $list$），随着操作进行，表前端就会留下越来越大的空区，而且这片空区永远不会用到





### 循环顺序队列

循环顺序队列：把一定大小的顺序表看作一种环形结构，认为其最后存储位置之后是最前的位置，形成一个环形

循环顺序队列的一种设计：

- 在队列使用中，顺序表的开始位置并不改变
- 队头变量 $q.head$ 记录当前队列里第一个元素的位置
- 队尾变量 $q.rear$ 记录当前队列里最后元素之后的第一个空位
- 队列元素保存在顺序表的一段连续单元里，即：[$q.head, q.rear$)

初始时队列为空，应该让 $q.head$ 和 $q.rear$ 取相同的值，表示顺序表里一个空段，具体取值无关紧要

出队和入队操作分别需要更新变量 $q.head$ 和 $q.rear$，正确的操作如下：

```python
q.head = (q.head + 1) % q.len        # 出队
q.rear = (q.rear + 1) % q.len        # 入队

q.head == q.rear                     # 队空
q.head == (q.rear + 1) % q.len       # 队满（采用这种方法将在表里留下一个不用的空位）
```