## 顺序表

顺序表的基本实现方式：表中元素顺序存放在一片足够大的连续存储区中，首元素存入存储区的开始位置，其余元素依次顺序存放。元素之间的逻辑顺序关系通过元素在存储区中的物理位置表示  ==>  隐式表示元素间的关系



设有一个顺序表对象，其元素存储在一片元素存储区中，该存储区的起始位置（内存地址）为 a0：

假定表元素编号从 0 开始，元素 e0 自然应存储在内存位置 Loc(e0) = a0

再假定表中一个元素所需的存储单元数为 c = size(元素)

则元素 ei 的地址计算公式为：Loc(ei) = a0 + c × i

> 存取操作（元素访问）可以在 O(1) 时间内完成



表元素存储块需要安排在计算机内存中，一旦分配就占据了内存的一块区域，有了固定的大小，并因此确定了元素个数的上限。而且，该块的前后都可能被其他有用对象占据，存储块的大小不能随便变化，特别是无法扩充

在一个顺序表的元素存储区中，一般情况是保存着一些元素，还存在一些可以存放元素的空位。在这种情况下，需要约定元素的存放方式，通常把已有元素连续存放在存储区的前面一段，空位都在后面。为了保证正确操作，就需要记录元素存储区的大小  ==> max 和当前的元素个数  ==>  sum



一个顺序表的完整信息包括两部分：

+ 表中的元素集合
+ 为实现正确操作而需记录的信息，即那些有关表的整体情况的信息  ==>  存储区容量、当前表中的元素个数



两种基本实现方式：

+ 一体式结构：存储表信息的单元与元素存储区以连续的方式安排在一块存储区中，几部分数据的整体形成一个完整的表对象

  > Loc(ei) = Loc(L) + C + i × size(e)          C：max 和 num 的存储量

+ 分离式结构（动态顺序表）：表对象里只保存与整个表有关的信息  ==>  容量、元素个数，实际元素存放在另一个独立的元素存储区对象中，通过链接与基本表对象关联



分离式结构的最大优点是带来了一种新的可能：可以在标识（id） 不变的情况下，为表对象换一块元素存储区。也就是说，表还是原来的表，其内容可以不变，但是容量改变了

在实际使用中，如果不断向一个顺序表里加入元素，最终一定会填满其元素存储区。如果该表采用一体式结构，此时再向表中加入元素的操作就会失败。由于表对象安排在内存中，它的两边可能有其他对象，一般而言，不可能直接扩大其存储。要想继续程序的工作，就只能另外创建一个容量更大的表对象，把元素搬过去，但这是一个新对象，要修改当时使用原对象的所有位置，使之改用新对象，这个任务通常很难完成

如果采用分离式结构，问题就很容易解决了。这时可以在不改变对象的情况下换一块更大的元素存储区：

1. 另外申请一块更大的元素存储区
2. 把表中已有的元素复制到新存储区
3. 用新的元素存储区替换原来的元素存储区  ==>  改变表对象的元素区链接
4. 实际加入新元素



## Python 的 list

Python 的 list 和 tuple采用了顺序表的实现技术，具有顺序表的所有性质

> tuple 是不变的表，因此不支持改变其内部状态的任何操作，在其它方面，与 list 类似



Python 的 list 的主要约束  ==>  分离式结构的顺序表：

+ 元素可变
+ 保序
+ 基于下标的高效元素访问和更新  ==>  O(1)
+ 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（id）不变



在 Python 的官方系统中，list 的实现采用了如下策略：创建空表时不分配元素存储区。遇到 insert() / append() 添加元素时，系统第一次分配能容纳 4 个元素的存储区。继续扩容时采用的策略是每次扩容的比率趋近 1.125



list 的主要操作的时间复杂度：

+ len()  ==>  O(1)  ==>  表中必须记录元素个数（num），自然可以简单的采用
+ 元素访问、赋值、尾端加入、尾端删除  ==>  O(1)
+ 一般位置的加入、切片替换、切片删除、表拼接（extend()）==>  O(n)



Python 的一个问题是：没有提供检查一个 list 对象的当前存储块容量的操作，也没有设置容量的操作

> 一切与容量有关的处理都由 Python 解释器自动完成



顺序表：

+  最大的优点：定位元素的时间复杂度是 O(1)
+ 最大得到缺点：加入 / 删除 的时间复杂度大部分为 O(n)，只有尾插 / 尾删 是 O(1)



























































































