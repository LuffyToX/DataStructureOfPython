# 栈

栈是一种容器，可存入数据元素、访问元素、删除元素等。存入栈中的元素之间相互没有任何具体关系，只有到来的时间先后顺序，在这里没有元素的位置、先后顺序的概念。栈的基本性质保证，在任何时刻可以访问、删除的元素都是在此之前最后存入的那个元素（栈顶元素）。因此，栈确定了一种默认元素访问顺序，访问时无需其他信息





## 栈抽象数据类型

```python
ADT Stack:
    Stack(self)                         # 创建空栈
    is_empty(self)                      # 判断栈是否为空（True / False）
    push(self, elem)                    # 将元素 elem 加入栈（压栈）
    pop(self)                           # 删除栈顶元素并返回（出栈）
    top(self)                           # 取得栈顶元素
```



栈可以实现为（看作）在一端进行 插入 / 删除 的线性表。在表实现中，执行插入和删除操作的一端称为 **栈顶**，另一端称为 **栈底**。用线性表的技术实现栈时，操作只在表的一端进行，不涉及另一端，更不涉及表的中间部分

- 对于顺序表，后端插入和删除操作是 $O(1)$ 操作，应该用这一端（表尾）作为栈顶
- 对于链接表，前端插入和删除操作是 $O(1)$ 操作，应该用这一端（表头）作为栈顶 





## 顺序栈

采用顺序表实现栈，首先会遇到实现顺序表时提出的各种问题，如：是采用简单顺序表实现，还是采用动态顺序表

- 一体式顺序表：可能出现栈满的情况，继续压入元素就会溢出，应该检查和处理
- 分离式顺序表：栈满时可以置换一个更大的存储区，这种情况下又会出现存储区的置换策略问题



$Python$ 的 $list$ 及其操作实际上提供了与栈的使用方式有关的功能，可以直接作为栈来使用

- 建立空栈：创建空表 $list()$
- 判空栈：检查是否为空表
- $list$ 采用动态顺序表技术，作为栈的表不会满
- 压栈：$lst.append()$
- 访问栈顶元素：$lst[-1]$
- 出栈：$lst.pop()$



把  $list$  当作栈使用，完全可以满足应用的需要。但是，这样建立的对象还是 $list$，提供了 $list$ 类型的所有操作，特别是提供了一大批栈结构原本不应该支持的操作，威胁栈使用的安全性.另外，这样的栈不是一个独立的类型，因此没有独立类型的所有重要性质

为了概念更清晰，实现安全，操作名也更易理解，可以考虑基于顺序表定义一个栈类，使之成为一个独立的类型，把 $Python$ 的 $list$ 隐藏在这个类的内部，作为其实现基础





## 链栈

链栈的基础结构就是单链表

由于 $list$ 可以自动扩大存储区，前面基于顺序表的栈类不会出现栈满的情况，因此应该能满足绝大部分的实际需要。在这种情况下，为什么还需要基于链表的栈实现？对这个问题的回答主要考虑顺序表的两个特点：

- 扩大存储区需要做一次高代价操作
- 顺序表需要完整的大块存储区

采用链接技术，在这两个问题上都有优势





## 栈的应用

栈是算法和程序里最常用的辅助结构，基本用途基于两个方面：

- 使用栈可以很方便地保存和取用信息，因此它常被作为算法或程序里的辅助存储结构，临时保存信息
- 栈具有后进先出的性质，利用这种性质可以保证特定的存取顺序，对于许多实际应用这种性质非常重要





### 示例 1：颠倒序列

栈可以用于颠倒一组元素的顺序：只需把元素按原来的顺序全部压栈，再顺序出栈，就能得到反序后的序列

```python
# 时间复杂度为 O(n)

ss = SStack()
lst2 = list()
for x in lst1:
    ss.push(x)
while not ss.is_empty():
    lst2.append(ss.pop_())
```

如果允许压栈和出栈操作任意交错，通过不同的压栈出栈操作序列，可以得到不同的元素序列。但请注意，这种做法并不能得到原序列的任意排列，结果序列有一定的规律性





### 示例2：括号匹配问题

检查括号配对的原则：

- 在扫描正文过程中，遇到闭括号应该与此前最近遇到且尚未获得匹配的开括号配对
- 如果最近未匹配开括号与当前闭括号不配对 / 找不到这样的开括号，就是匹配失败



由于存在多种不同的括号对，每种括号都可能出现任意多次，而且还可能嵌套，为了检查是否匹配，扫描中必须保存遇到的开括号；由于写程序时无法预知要处理的正文里会有多少需要保存，因此不能用固定数目的变量保存，必须用缓存结构；由于括号的出现可能嵌套，需要逐对匹配：当前括号应该与前面最近的尚未配对的开括号匹配，这说明，需要存储的开括号的使用原则是后存入者先使用，即 **LIFO** 原则；如果一个开括号已配对，就应该删除

1. 顺序扫描被检查正文（一个字符串）里的一个个字符
2. 检查中跳过无关字符（所有非括号字符都与当前处理无关）
3. 遇到开括号时，就将其压栈
4. 遇到闭括号时，弹出当前的栈顶元素并与之匹配
5. 如果匹配成功则继续，发现不匹配时检查以失败结束





### 示例3：表达式的表示、计算和变换

**中缀表达式**：二元运算符写在其两个运算对象中间（最常见的表达形式）

> 它不足以表示所有可能的运算顺序，需要通过辅助记号、约定和辅助描述机制
>
> - 必须引进括号的概念，规定括号里的运算先做，以便于人们直接说明一些计算的特定顺序
> - 给各种运算符规定了不同的优先级，多个运算符相继出现时，优先级高的运算先做
> - 有了这些还不够，还要规定具有相同优先级的运算符相继出现时的计算顺序

**前缀表达式**：所有运算符都写在他们的运算对象之前，亦称波兰表达式

**后缀表达式**：所有运算符都写在他们的运算对象之后，亦称逆波兰表达式（特别适合计算机处理）

下面是同一算术表达式的等价表示形式：

- 中缀形式：`(3-5) * (6 + 17*4) / 3​`
- 前缀形式：`/ * - 3 5 + 6 * 17 4 3​`
- 后缀形式：`3 5 - 6 17 4 * + * 3 /`





#### 后缀表达式的计算

根据后缀表达式的计算规则，计算过程应该是顺序检查表达式里的一个个项，分两种情况：

+ 遇到运算对象：记录，以备后面使用
+ 遇到运算符：根据其元数，取得前面最近遇到的几个运算对象/已完成运算的结果，计算并保存结果



在这里又遇到了需要记录信息以备将来使用的问题，必须用一个缓存结构：

+ 需要记录的是已经掌握的数据，无论这些数据是直接由外部得到，还是计算出来，都需要缓存（尚不可用）
+ 每次处理运算符，应使用的是此前最后记录的几个结果（具体项数应该根据运算符的元数确定）

显然，这里的情况是后保存先使用（**LIFO**），应该用栈作为缓存结构





#### 中缀表达式到后缀表达式的转换

中缀形式：`(3-5) * (6 + 17*4) / 3`

后缀形式：`3 5 - 6 17 4 * + * 3 /`

对照两个表达式，可以看到转换中需要考虑的一些基本情况：

+ 在扫描中缀表达式的过程中，如果遇到运算对象，就应该直接将其送出，作为后缀表达式的一个项
+ 把运算符放入后缀表达式也就是要求运算，需要仔细控制送出的时机



在考虑运算符在后缀表达式里的出现位置时，必须处理好中缀表达式的优先级和结合性问题：

+ 扫描中遇到一个运算符时不能将其送出，只有看到下一运算符的优先级不高于本运算符时，才能够送出
+ 可以看到，在这个过程中，总要拿当前运算符与前面最近的且尚未送走的运算符比较，而且可能删除前面的运算符，这也是后保存的信息先使用（与前面保存的最后一个运算符比较，而且还可能用掉它）。另一方面，处理中需要记录的运算符个数也无法事先确定，因此应该用一个栈保存尚未处理的运算符
+ 另一方面，转换中还需要处理括号的问题。表达式里的括号是配对的，左括号标明了一个应该优先计算的子表达式的起点，需要记录；右括号说明应该优先计算的子表达式到此为止。因此，在遇到右括号时，需要逐个弹出栈里的运算符（排在后面的必定具有更高优先级），直至遇到左括号时也将其弹出
+ 此外，在扫描完整个中缀表达式时，栈里可能还剩下一些运算符。他们的计算都应该进行，也就是说，应该把它们一一弹出送到后缀表达式





#### 中缀表达式的求值

直接求中缀表达式的值，需要统一考虑以下问题：

+ 运算符的优先级
+ 括号的作用
+ 根据扫描表达式过程中的情况，确定完成各个运算的时机
+ 在需要做某个运算时，能找到正确的运算对象



由于现在要计算中缀表达式，扫描中遇到运算对象时不能输出，而应该临时保存起来，在需要用的时候能比较容易地找到它们。根据后缀表达式的计算规则：每当需要执行一个运算时，对应的运算对象应该是前面最近遇到的运算对象或最近计算得到的结果。在后缀表达式计算器里用一个栈保存这些数据，现在可以模拟它，另外引进一个数据栈，保存运算对象和计算得到的中间结果

1. 扫描中遇到运算对象将其压入数据栈
2. 遇到运算符和括号时，按照前面转换算法中的方式，分几种情况处理：
   + 左括号：压入运算符栈
   + 右括号：弹出运算符完成计算，直至弹出对应左括号
   + 其他运算符：按照前面做法，基于优先级处理
3. 确定了应该应用一个运算符时：
   + 其运算对象就是数据栈顶的两个项
   + 完成计算得到的结果还需要压进数据栈
4. 整个表达式处理完后，逐项弹出运算符栈剩下的运算符并完成计算























