[TOC]

# 排序

排序就是整理数据的序列，使其中元素按照特定顺序排列的操作

> 在排序的过程中，序列里的数据元素保持不变，但其排列顺序可能改变



排序可以使数据的存储方式更具结构性，有利于对它们处理

+ 排好序的序列可以采用二分查找（效率高）
+ $Kruskal$ 算法中需要对图中的边按权值排序
+ 最佳二叉树生成算法需要所有的数据序列按关键码排序



一次具体排序总是针对某数据集合 $S$ 的元素组成的序列进行的，基于集合 $S$ 上的某种具体的序关系

> 一类常见的序关系是该集合上的全序



假设数据集合 $S$ 的元素上有一个序关系 $\leq$，一个排序算法 $sort$ 就是从 $S$ 的元素序列到 $S$ 的元素序列的映射

> 对 $S$ 的任意元素序列 $s$，$s'=sort(s)$ 是 $s$ 的一个排列，使得 $s'$ 中任意一对相邻元素 $e$ 和 $e'$，都有 $e\leq e'$



这里假设需要排序的是某种数据记录的序列 $R_0、R_1、\cdots、R_{n-1}$

- 每个记录里有一个或几个支持排序的关键码，这些关键码相对简单，存在易于判断的序关系，如：
  - 关键码是整数，序关系是整数的 “小于等于”
  - 关键码是字符串，序关系是字符串的字典序
- 在数据记录里还可以有任意多的其他成分，但它们与排序无关，可以忽略



基于关键码的排序，也就是根据记录中所考虑的那个关键码的序关系整理记录序列，使之成为按关键码排序的序列

+ 按关键码递增排序
+ 按关键码递减排序



排序方式

+ 内排序：待排序的记录全部保存在内存中
+ 外排序：待排序的记录保存在外存（磁盘、磁带等）



排序工作要求数据集合中存在一种可用的序，如果数据本身没有自然的序，也可以给它造出一种序

> 最典型的方法就是设计一种 $hash$ 函数，把数据集的元素映射到某个有序集



最优时间复杂度：基于关键码比较的排序问题，实现这一过程的任何算法都不可能优于 $O(nlogn)$



排序算法得两个性质：

+ 稳定性：稳定的排序算法能够维持序列中所有排序码相同记录得相对位置

+ 适应性：如果一个排序算法对接近有序的序列工作得更快，就称这种算法具有适应性





## 简单排序算法

简单排序算法的共同特点是：简单且最坏情况得时间复杂度高





### 插入排序

插入排序的基本操作方式是插入：不断地把一个个元素插入一个序列中，最终得到排序序列

> 作为插入操作的起点，需要有一个初始的已排序序列：
>
> + 无元素序列
> + 只有一个元素的序列



考虑连续表排序，希望尽可能少用辅助空间，最合适的方法是把正在构造的排序序列嵌入原来的表中

> 如此一来，排序中就只需要用几个简单变量，算法就可以做到只需要 $O(1)$ 的空间复杂度



**插入排序过程中的状态**

| 有序部分 | $d$  | 无序部分（$d$ 是无序部分的首元素） |
| -------- | ---- | ---------------------------------- |
|          | $i$  |                                    |

+ 在连续表的前段积累已排序序列，通过这个序列的不断生长，最终完成整个序列的排序工作
+ 在连续表的后段是尚未处理的元素，每次考虑这段元素的最左元素，即上图 $i$ 标识的元素





### 选择排序

在插入排序中，每次操作处理哪个记录并不重要，关键在于把被处理记录插入已排序序列中的正确位置，因此可以采用最简便的方式取记录，即按顺序提取。选择排序的想法与之对应，这里的基本操作是选择合适记录，只要严格按递增方式选出记录，简单地顺序排放就能完成排序工作（递减序列则反之）

+ 维护需要考虑的所有记录中最小的 $i$ 个记录的已排序序列
+ 每次从剩余未排序的记录中选取关键码最小的记录，将其放在已排序序列记录的后面，作为序列的第 $i+1$ 个记录，使已排序序列增长
+ 以空序列作为排序工作的开始，做到尚未排序的序列里只剩一个元素时（它必然为最大），只需直接将其放在已排序的记录之后，整个排序就完成了



#### 简单选择排序

顺序扫描序列中的元素，记住遇到的最小元素，一次扫描完毕就找到了一个最小元素，反复扫描就能完成排序工作；另一方面，选出了一个元素，原来的序列中就出现了一个空位，可以把这些空位集中起来存放排好序的序列



**选择排序中的状态**

| 有序部分 | $d$   | 无序部分（$d$ 是无序部分的首元素） |
| -------- | ----- | ---------------------------------- |
|          | $i+1$ |                                    |

+ 在连续表的前段积累一批递增的已经排好序的记录，而且它们都不大于任何一个未排序记录

+ 下一步从未排序记录中选出最小的记录，将其存放在已排序记录段的末尾（即上图 $i+1$）

  > 将选出的记录与 $i+1$ 处的记录互换

+ 这样，在只剩一个记录时，其关键码一定最大，工作即可结束





#### 堆排序

简单选择排序低效的原因在于：每次选择一个元素，都是从头开始做一遍完全的比较

> 在整个排序过程中做了很多重复比较工作



堆排序是一种高效的选择排序算法，该算法高效的主要原因在于：

+ 堆里积累了前面所做的比较中得到的信息，由于堆的结构特征，这种信息可以很自然地重复利用
+ 由于堆和顺序表的关系，一个堆和一个排序序列可以很方便地嵌入同一个顺序表，不需要任何辅助结构





### 交换排序（起泡排序）

一个序列中的记录没排好序，那么其中一定有逆序存在

+ 如果交换所发现的逆序记录对，得到的序列将更接近排序序列
+ 通过不断减少序列中的逆序，最终可以得到排序序列



起泡排序是一种典型的通过交换元素消除逆序实现排序的方法，其基本操作是比较相邻记录，发现相邻的逆序对时就交换它们，通过反复比较和交换，最终完成整个序列的排序工作

> 如果序列中每对相邻记录的顺序正确，整个序列就是一个排序序列



**起泡排序过程示例**

```bash
初始态：30  13  25  16  47  26  19  10

第一遍：13  25  16  30  26  19  10  47

第二遍：13  16  25  26  19  10  30  47

第三遍：13  16  25  19  10  26  30  47

第四遍：13  16  19  10  25  26  30  47

第五遍：13  16  10  19  25  26  30  47

第六遍：13  10  16  19  25  26  30  47

第七遍：10  13  16  19  25  26  30  47

```

+ 每一遍检查可以把一个最大元素交换到位，一些较大元素后移一段，可能移动很远

  > 经过 $n-1$ 遍扫描，一定能完成排序

+ 从左到右比较，导致小元素一次只左移一位，个别距离目标位置很远的小元素可能延误整个排序进程





## 快速排序

快速排序的实现中也采用了发现逆序和交换记录位置的方法，但算法中最基本的思想是划分，即按某种标准把考虑的记录划分为 “小记录” 和 “大记录”，并通过递归不断划分，最终得到一个排序的序列，其基本过程是：

+ 选择一种标准，把被排序序列中的记录按这种标准划分为大小两组

  > 从整体的角度，这两组记录的顺序已定，较小一组的记录应该排在前面

+ 采用同样的方式，将这两组记录继续递归地划分下去

+ 划分总是得到越来越小的分组，如此下去，直到每个记录组中最多包含一个记录时，整个序列的排序完成









## 归并排序









## Python 的 list 排序

内置的排序函数 $sort$ 可以对任何可迭代对象排序，得到一个排序的表；另外，表 $list$ 类也有一个 $sort$ 方法

> 两者共享同一个排序算法，这是一种混成式的排序算法，称为 $Timsort$（蒂姆排序）



蒂姆排序是一种基于归并技术的稳定排序算法，结合使用了归并排序和插入排序技术

+ 最坏时间复杂度是 $O(nlogn)$ 
+ 该算法具有适应性，在被排序的数组元素接近好序的情况下，它的时间复杂度可能达到 $O(n)$ 
+ 在最坏的情况下需要 $n/2$ 的工作空间，因此其空间复杂度为 $O(n)$
+ 如果情况有利，它只需要很少的临时存储空间 



蒂姆排序比较适合许多实际应用中常见的情况，特别是被排序的数据序列分段有序或者基本有序，但其中也有些非有序元素的情况。人们通过许多试验，结论是蒂姆排序在平均性能上超过快速排序，是目前实际表现最好的排序算法，虽然它未能从理论上克服归并排序 $O(n)$ 空间开销的弱点，但实际中经常不需要很大的工作空间



蒂姆排序克服了归并排序没有适应性的缺陷，又保持了其稳定性的特征，并尽可能利用实际数据的情况

+ 考察待排序序列中非严格单调上升或严格单调下降的片段，反转其中的严格单调下降片段

+ 采用插入排序，对连续出现的几个特别短的上升序列排序，使整个序列变成一系列非严格单调上升的记录片段

  > 每个片段都长于某个特定值

+ 通过归并产生更长的排序片段，控制这一归并过程，保证片段的长度尽可能均匀

  > 归并中采用一些策略，尽可能地减少临时空间的使用

+ 通过反复归并，最终得到排序序列





## 几种排序算法的比较

| 排序算法     | 最坏时间复杂度 | 平均时间复杂度 | 最优时间复杂度 | 空间复杂度 | 稳定性 | 适应性 |
| ------------ | -------------- | -------------- | -------------- | ---------- | ------ | ------ |
| 插入排序     | $O(n^2)$       | $O(n^2)$       | $O(n)$         | $O(1)$     | √      | √      |
| 简单选择排序 | $O(n^2)$       | $O(n^2)$       | $O(n^2) $      | $O(1)$     | ×      | ×      |
| 堆排序       | $O(nlogn)$     | $O(nlogn)$     | $O(nlogn)$     | $O(1)$     | ×      | ×      |
| 起泡排序     | $O(n^2)$       | $O(n^2)$       | $O(n)$         | $O(1)$     | √      | √      |
| 快速排序     | $O(n^2)$       | $O(nlogn)$     | $O(nlogn)$     | $O(logn)$  | ×      | ×      |
| 归并排序     | $O(nlogn)$     | $O(nlogn)$     | $O(nlogn)$     | $O(n)$     | √      | ×      |
| 蒂姆排序     | $O(nlogn)$     | $O(nlogn)$     | $O(n)$         | $O(n)$     | √      | √      |

