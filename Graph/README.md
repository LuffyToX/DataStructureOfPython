# 图

一个图是一个二元组 $G=(V,E)$：

+ $V$ 是非空有穷的顶点集合（顶点是图中的基本个体，可以表示任何讨论中需要关心的实体）
+ $E$ 是顶点偶对（也称为边）的集合，$E\subseteq V\times V$

一个重要的性质：$\mid E\mid \leq \mid V\mid ^2$，也就是说，对于不同的图，其中边的条数最大为顶点个数的平方



图分为有向图和无向图：

+ 有向图：图中的边有方向，如：$<v_i,v_j>$ 表示从顶点 $v_i$ 到顶点 $v_j$ 的有向边
+ 无向图：图中的边无方向，如：$(v_i,v_j)$ 与 $(v_j,v_i)$ 表示同一条无向边



如果在图 $G$ 中有边 $<v_i, v_j>\in E$（对于无向图，有 $(v_i,v_j)\in E$），则称顶点 $v_j$ 为 $v_i$ 的邻接点（无向图里的邻接关系是双向的），也称这条边为 $v_i$ 的邻接边，也就是说，边集合 $E$ 表示的是顶点之间的邻接关系



完全图：任意两个顶点之间都有边的图（有向图或无向图）称为完全图

+ $n$ 个顶点的无向完全图有 $C_n^2=n(n-1)/2$ 条边
+ $n$ 个顶点的有向完全图有 $2C_n^2=n(n-1)$ 条边

![完全图](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=348156199,1935306188&fm=26&gp=0.jpg)



度：一个顶点的度就是与它邻接的边的条数

> 对于有向图，顶点的度还分为出度和入度
>
> + 入度：以该顶点为终点
> + 出度：以该顶点为起点

无论对于有向图还是无向图，顶点数 $n$、边数 $e$ 和顶点度数 $\sum D(v_i)$ 之间都有如下关系：
$$
e=\frac{1}{2}\sum_{i=1}^n D(v_i)
$$


**路径**

对于图 $G=(V，E)$，如果存在序列 $v_0、v_1、\cdots 、v_m$，使得 $(v_0，v_1)、(v_1，v_2)、\cdots 、(v_{m-1}，v_m)\in E$，则说从顶点 $v_0$ 到顶点 $v_m$ 存在路径，并称 $(v_0、v_1、\cdots、v_m)$ 是二者间的一条路径（对于有向图同理）

+ 路径的长度就是该路径上边的条数
+ 回路（环）指起点和终点相同的路径
+ 如果一个环除起点和终点外的其他顶点均不相同，则称为简单回路（简单回路也是简单路径）
+ 简单路径是指内部不包含回路的路径（该路径上的顶点除起点和终点可能相同外，其他顶点均不相同）

如果从 $v_i$ 到 $v_j$ 存在存在非简单的路径（包含环路的路径），那么从 $v_i$ 到 $v_j$ 就有无穷多条不同的路径（绕圈）



有根图：如果在有向图 $G$ 中存在一个顶点 $v$，从顶点 $v$ 到图 $G$ 中其他每个顶点均有路径，则称 $G$ 为有根图（$v$）



**连通图**

连通：如果在无向图 $G$ 中存在从 $v_i$ 到 $v_j$ 的路径，则称从 $v_i$ 到 $v_j$ 连通，或称从 $v_i$ 可达 $v_j$

> 无向图的连通性是双向的
>
> 对有向图也可有类似的定义，只是连通性不一定是双向的

连通图：如果无向图 $G$ 中任意两个顶点 $v_i$ 与 $v_j$ 之间都连通，则称 $G$ 为连通无向图，简称连通图

强连通图：对于有向图 $G$ 中任意两个顶点 $v_i$ 与 $v_j$，双向都连通，则称 $G$ 为强连通有向图，简称强连通图

+ 完全无向图都是连通图
+ 完全有向图都是强连通图

最小连通无向图的边数：包含 $n$ 个顶点的最小连通无向图 $G$ 有 $n-1$ 条边

> 最小连通图：本身为连通图，但去掉其中任一条边将不再是连通图

最小有根图的边数：包含 $n$ 个顶点的最小有根图 $G$ 有 $n-1$ 条边

> 最小有根图：本身为有根图，但去掉其中任一条边将不再是有根图



**子图、连通子图**

对于 $G=(V，E)$ 和 $G'=(V'，E')$，如果 $V'\subseteq V$ 且 $E'\subseteq E$，就称 $G'$是 $G$ 的子图（$G$ 是其自身的子图）

一个图可能不是连通图（或强连通图），但它的一些子图则可能是连通的（或强连通的）



图 $G$ 的一个极大连通子图（或称连通分量）$G'$ 是图 $G$ 的一个连通子图，且 $G$ 中不存在真包含 $G'$ 的连通子图

> 从连通性的角度看，图 $G'$ 的顶点和边集都已经不能扩充，是极大的（否则就不连通）
>
> + 如果图 $G$ 本身连通，它将只有一个连通分量，就是 $G$ 本身
> + 如果图 $G$ 本身不连通，则其连通分量多于一个

无向图 $G$ 的所有连通分量形成了图 $G$ 的一个划分，每个连通分量包含图 $G$ 的一集顶点和它们之间的所有边，不同连通分量的顶点集合互不相交，而这些顶点集和边集的并就是原来的 $G$



有向图 $G$ 的一个极大强连通子图称为它的一个强连通分量，但请注意，图 $G$ 的强连通分量只形成其顶点的一个划分，所有强连通分量的并未必等于图 $G$，可能少一些连接不同连通分量的有向边，这一点与无向图不同



**带权图、网络**

如果图 $G$ 中的每条边都被赋予一个权值，则称 $G$ 为一个带权图

+ 带权有向图
+ 带权无向图（带权的连通无向图也被称为网络）





## 图的抽象数据类型

```python
ADT Graph:
    Graph(self)                           # 构造图
    is_empty(self)                        # 判断是否为空图
    vertex_num(self)                      # 获取该图中顶点的个数
    edge_num(self)                        # 获取该图中边的条数
    vertices(self)                        # 获取该图中的顶点集合
    edges(self)                           # 获取该图中的边集合
    add_vertex(self, vertex)              # 将顶点 vertex 加入该图
    add_edge(self, v1, v2)                # 将从 v1 到 v2 的边加入该图
    get_edge(self, v1, v2)                # 获取 v1 到 v2 边的有关信息
    out_edges(self, v)                    # 获取从顶点 v 出发的所有边
    degree(self, v)                       # 检查顶点 v 的度
```

图的遍历与树的遍历有较大差异，主要在于：

+ 图中可能有回路，到同一个顶点可能有多条路径，因此在遍历中需要避免再次进入已经遍历过的部分
+ 图有可能不连通或者这个图不是有根图，即使是有根图，也可能没有从图中的根开始遍历。因此要完成对一个图里所有顶点或边的遍历，遍历完图中可达的那个部分，还需要考虑从初始顶点不可达的部分





## 图的表示

在抽象的讨论中，主要关注的是边与顶点的邻接关系和顶点间的邻接关系，这些是图表示的关键





### 邻接矩阵

邻接矩阵是表示图中顶点间邻接关系的方阵：对于 $n$ 个顶点的图 $G=(V，E)$，其邻接矩阵是一个 $n\times n$ 的方阵，图中每个顶点（按顺序）对应于矩阵里的一行和一列，矩阵元素表示图中的邻接关系

+ 非带权图（以 $0$、$1$ 为矩阵元素）
  $$
  A_{ij}=\begin{equation}
         \left\{
                     \begin{array}{lr}
                     1 && 如果顶点 v_i 到 v_j 有边 \\
                     0 && 如果顶点 v_i 到 v_j 无边                 
                     \end{array}
         \right.
         \end{equation}
  $$

+ 带权图（以权值为矩阵元素）
  $$
  A_{ij}=\begin{equation}
         \left\{
                     \begin{array}{lr}
                     w(i,j) \qquad 如果顶点 v_i 到 v_j 有边，且该边的权是 w(i,j) \\
                     0\,或\,\infty \qquad 如果顶点 v_i 到 v_j 无边                 
                     \end{array}
         \right.
         \end{equation}
  $$



**邻接矩阵示例**：
$$
A_4=\left[
        \begin{matrix}
        0 & 1 & 1 & 0 \\
        1 & 0 & 1 & 0 \\
        1 & 1 & 0 & 1 \\
        0 & 0 & 1 & 0  
        \end{matrix} 
     \right]
$$

+ 无向图的邻接矩阵都是对称阵（邻接关系是对称的），有向图则不一定

+ 由于没有考虑顶点到自身的边，上面矩阵的主对角线元素都是 $0$
+ 邻接矩阵中的下标 $i$ 的一行和一列都对应于顶点 $i$：
  + 行对应于它的出边，非零元的个数对应于顶点 $i$ 的出度
  + 列对应于它的入边，非零元的个数对应于顶点 $i$ 的入度



**邻接矩阵的缺点**

图的邻接矩阵经常是比较稀疏的，其中有信息的元素比例不大，大量元素是表示无边的值

如果在计算过程中需要遍历图中的所有边，采用邻接矩阵表示，至少要花费等比于顶点数平方的时间





### 邻接表

邻接表：为图中每个顶点关联一个边表，记录这个顶点的所有邻接边（一个顶点表，其中每个顶点关联一个边表）

+ 顺序表表示图中的顶点
+ 链接表表示顶点关联的边表



**无向图邻接表示例**：

![邻接表](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2607316520,3128501450&fm=26&gp=0.jpg)

上图仅表示了它的邻接关系，如果要表示边的权值，就需要在每个链表结点里增加相应的域





## 图的基本算法

很多实际问题可以抽象为图和图上的计算问题：

+ 互联网和移动电话网的路由
+ 集成电路和印刷电路板的设计和布线
+ 运输和物流中的各种规划安排问题
+ 工程项目的计划安排

图算法的复杂度十分重要，因为它需要处理的问题规模可能很大





### 图的遍历

图的遍历就是按某种方式系统地访问图中每个顶点且仅访问一次的过程，这也称为图的周游

+ 顶点可能具有可利用的结构，如：采用邻接矩阵或邻接表表示的图就可以通过下标遍历所有顶点
+ 要求基于图中顶点的邻接关系进行遍历，如：找出一个顶点可达的所有顶点，这就必须基于图的结构遍历



基于图结构的遍历只能从一个（或几个）顶点出发，根据图的结构只能访问顶点所在的连通分量（对于有向图，是该顶点的可达子图）里的全部顶点。由于被处理的图可能不连通，要完成整个图的遍历，在完成了一个可达部分的遍历后，还需要考虑对图中尚未遍历的其他部分的处理

+ 深度优先遍历
+ 广度优先遍历

图中到达同一顶点的路径可能不止一条，还可能存在回路，因此，在遍历中必须避免多次处理图中同一部分的问题





#### 深度优先遍历 DFS

假定从指定顶点 $v$ 出发：

+ 首先访问顶点 $v$，并将其标记为已访问
+ 检查 $v$ 的邻接顶点，选一个尚未访问的顶点，从它出发继续进行深度优先搜索，不存在这种邻接顶点时回溯
+ 反复上述操作直到从 $v$ 出发可达的所有顶点都已访问（递归）
+ 如果图中还存在未访问的顶点，则选出一个未访问点，由它出发重复前述过程，直到图中所有顶点都已访问

通过深度优先遍历顺序得到的顶点序列称为该图的深度优先搜索序列，简称 DFS 序列

> DFS 序列不唯一





#### 广度优先遍历 BFS

假设从指定顶点 $v$ 出发：

+ 先访问顶点 $v$，并将其标记为已访问
+ 依次访问 $v$ 的所有邻接顶点 $v_0，v_1,\cdots,v_{m-1}$（可能规定某种顺序）
+ 再依次访问与 $v_0,v_1,\cdots,v_{m-1}$ 邻接的所有尚未访问过的顶点，$\cdots$，直到所有可达顶点都已访问
+ 如果图中还存在未访问的顶点，则选出一个未访问点，由它出发重复前述过程，直到图中所有顶点都已访问

通过广度优先遍历顺序得到的顶点序列称为该图的广度优先搜索序列，简称 BFS 序列

> 如果规定了图中各顶点的邻接点顺序，BFS 序列就确定了





### 生成树

下面的讨论都是基于此二种图：

+ 如果图 $G$ 是连通无向图，从 $G$ 中任一顶点 $v_0$ 出发到图中其他各个顶点都存在路径

+ 如果图 $G$ 是强连通有向图（有根有向图即可），从 $G$ 的根 $v_0$ 出发到图中其他各个顶点都存在路径



如果图 $G$ 有 $n$ 个顶点，必然可找到 $G$ 中的一个包含 $n-1$ 条边的边集合，包含了从 $v_0$ 到其他所有顶点的路径

> 图 $G$ 中满足上述性质的 $n-1$ 条边（加上 $G$ 的所有顶点）形成了图 $G$ 的一个子图 $T$
>
> 由于 $T$ 包含 $n$ 个顶点且只有 $n-1$ 条边，因此它不可能包含任何回路，形成了一棵树（以 $v_0$ 为根节点）

+ 对无向连通图 $G$：子图 $T$ 是 $G$ 的一个最小连通子图（由于 $T$ 是树形结构，因此称 $T$ 为 $G$ 的一棵生成树）
+ 对有向强连通图 $G$：子图 $T$ 是 $G$ 的一个最小有根子图（以 $v_0$ 为根），$T$ 也称为 $G$ 的一棵生成树



生成树的边数：$n$ 个顶点的连通图 $G$ 的生成树包含 $n-1$ 条边

+ 无向图 $G$ 的生成树就是 $G$ 的一个最小连通子图，是一个无环图

  > 任何无向图都可以划分为一组连通分量，因此每个无向图都存在生成树林

+ 有向图 $G$ 的生成树中所有边都位于从根到其他顶点的（有方向的）路径上



**构造生成树**

从连通无向图或强连通有向图中任一顶点出发遍历，或从有根有向图的根结点出发遍历，都可以访问到所有结点

> 在遍历中经过的边加上原图的所有顶点，就构成该图的一棵生成树

遍历构造生成树的过程可以按深度优先或广度优先，在遍历中记录访问的所有顶点和经过的边，就得到原图的：

+ 深度优先生成树（DFS 生成树）
+ 广度优先生成树（BFS 生成树）



生成树上的边形成了从初始顶点到其他顶点的一簇路径，在这簇路径里：

+ 一个顶点可能有多个 “下一顶点”
+ 一个顶点至多有一个 “上一顶点”

记录路径：记录所有的 “前一顶点” 关系，遍历完所有顶点之后，根据 “前一顶点” 关系就能回溯出所有路径

在考虑路径的 “前一顶点” 关系时，对应每个顶点只需要记录一项信息

> 设图中有 $vnum$ 个顶点，可以用一个包含 $vnum$ 个元素的列表 $spanForest$ 记录得到的路径信息
>
> 令表项 $spanForest[v_i]$ 的形式是二元组 $(v_j, e)$：
>
> + $v_j$：从 $v_0$ 到 $v_i$ 的路径上 $v_i$ 的前一顶点
> + $e$：$v_j$ 到 $v_i$ 的权值





## 最小生成树

假定 $G$ 是一个网络，其中的边带有给定的权值，自然也就可以做出它的生成树：

+ 网络 $G$ 的一棵生成树中各边的权值之和称为该生成树的权
+ 网络 $G$ 可能存在多棵不同的生成树（权值可能不同），权值最小的生成树称为 $G$ 的最小生成树（$MST$）
+ 任何一个网络都必然有最小生成树，但其最小生成树也可能不唯一

> 应用示例：
>
> + 顶点：城市
> + 边：连接城市的通信网
> + 边的权：连接城市的通信线路的成本
>
> 如此，根据最小生成树建立的通信网就是这些城市之间成本最低的通信网





### $Kruskal$（克鲁斯卡）算法

设 $G=(V,E)$ 是一个网络，其中 $|V|=n$，$Kruskal$ 算法构造最小生成树的过程：

+ 初始时取包含 $G$ 中所有 $n$ 个顶点但没有任何边的孤立点子图 $T=(V,\{\})$

  > $T$ 中的每个顶点自成一个连通分量，下面将通过不断扩充 $T$ 的方式构造 $G$ 的最小生成树

+ 将边按权值递增的顺序排序，每一步都找下一条两端点位于 $T$ 的两个不同连通分量的边 $e$，把 $e$ 加入 $T$

  > 这导致两个连通分量由于边 $e$ 的连接而变成了一个连通分量

+ 每次操作使 $T$ 减少一个连通分量，不断重复这个动作加入新边，直到 $T$ 中所有顶点都包含在一个连通分量里

  > 这个连通分量就是 $G$ 的一棵最小生成树

如果这样做不能得到一个包含 $G$ 的所有顶点的连通分量，则原图不连通，没有最小生成树



算法中有两个问题需要考虑：

+ 当前最短边的选取

  > 有多种可能做法：
  >
  > 1. 每次扫描剩下的边，选出最短边
  > 2. 先将所有的边排序后顺序选取
  > 3. 构造一个优先队列

+ 如何判断两个顶点在当时的 $T$ 里属于不同连通分量

  > 为每个连通分量确定一个 **代表元**，如果两个顶点的代表元相同，它们就相互连通，属于同一连通分量
  >
  > 
  >
  > 需要时刻记录和维护（必要时更新）每个顶点的代表元，最麻烦的是合并连通分量时的代表元维护：加入一条边减少了连通分量，这时需要选一个顶点，让被合并的两个连通分量里的顶点都以它为代表元
  >
  > > 完成这件事最简单的方法是从原来的两个代表元中任选一个，而后更新另一连通分量中顶点的代表元
  >
  > 
  >
  > 假设用下标为顶点编号的列表 $reps$ 表示代表元关系：
  >
  > + 从顶点出发找到代表元只需 $O(1)$ 时间
  >
  > + 初始时，每个顶点都应该以其自身作为代表元（$reps[i]=i$），因为它所在的连通分量里只有自己
  > + 在算法过程中需要不断更新 $reps$，保证 $reps[v]$ 总是顶点 $v$ 的代表元下标





### $Prim$（普林姆）算法

$Prim$ 算法的设计基于最小生成树的一种重要性质：从一个顶点出发，逐步扩充包含该顶点的部分生成树 $T$



**MST 性质**

设 $G=(V,E)$ 是一个网络，$U$ 是 $V$ 的任一真子集，设 $e=(u,v)\in E$ 且 $u\in U，v\in V-U$，且 $e$ 在 $G$ 中所有一个顶点在 $U$ 而另一个顶点在 $V-U$ 的边中权值最小，那么 $G$ 必有一棵包括边 $e$ 的最小生成树



$Prim$ 算法是 $MST$ 性质的直接应用，其基本思想是：从一个顶点出发，利用 $MST$ 性质选择最短连接边，扩充已连接的顶点集并加入所选的边，直至结点集合里包含了图中的所有顶点，或最终确定这个图不是连通图

+ 从图 $G$ 的顶点集 $V$ 中任取一顶点（如： $v_0$）放入集合 $U$ 中，此时 $U=\{v_0\}$，令边集合 $E_T=\{\}$

  > 显然，$T=(U,E_T)$ 是一棵树（只包含一个顶点且没有边）

+ 检查所有一个顶点在集合 $U$ 而另一个顶点在集合 $V-U$ 的边，找出其中权值最小的边 $e=(u,v)$，将顶点  $v$ 加入顶点集合 $U$，并将 $e$ 加入边集合 $E_T$

  > 扩充后的 $T=(U,E_T)$ 仍是一棵树

+ 重复上面步骤直到 $U=V$（所构造的树已经包含了所有顶点）

  > 此时集合 $E_T$ 里有 $n-1$ 条边，子图 $T=(U,E_T)$ 就是 $G$ 的一棵最小生成树





## 最短路径

带权有向图 / 带权无向图（网络）中的每条边都附有一个权值，通常用于表示实际应用中顶点之间联系的某种度量

+ 从顶点 $v$ 到 $v'$ 的一条路径上各条边的长度之和称为该路径的长度

+ 从顶点 $v$ 到 $v'$ 的所有路径中，长度最短的路径就是 $v$ 到 $v'$ 的最短路径

  > 最短路径的长度称为从 $v$ 到 $v'$ 的距离，记为：$dis(v, v')$



最短路径在实际应用中特别有意义，许多调度问题与此有关，如：

+ 运输（最短里程、最少运费、最低成本、最短时间、$\cdots$）
+ 加工或者工作流程
+ $\cdots$



最短路径问题：

+ 单源点最短路径（从一个顶点出发到图中其余各顶点的最短路径）
+ 任意顶点间的最短路径





### 求解单源点最短路径的 $Dijkstra$（狄克斯特拉）算法

该算法能求出一个给定顶点到图中所有其他顶点的最短路径

> 该算法也顺便解决了对给定顶点 $v$ 和目标顶点 $v'$ 之间最短路径的问题



**基本想法**

$Dijkstra$ 算法的限制：要求图中所有边的权不小于 $0$



$Dijkstra$ 算法把图中的顶点分为两个集合：

+ 已知的最短路径上的顶点集合 $U$
+ 未知的最短路径上的顶点集合 $V-U$

在算法的执行过程中逐步扩充已知最短路径的顶点集合（每步从顶点集合 $V-U$ 中找出一个顶点加入 $U$）

> 该算法能同时给出这些最短路径及其长度（距离）



针对程序执行中的每个时刻，为图中所有顶点定义一种与初始点 $v_0$ 相关的统一度量，称为已知最短路径长度：
$$
cdis(v_0,v)=
\begin{equation}
\left\{
             \begin{array}{lr}
             dis(v_0,v) & if\,\,\,v\in U                                 \\
             min\{dis(v_0,u)+w(u,v)|u\in U\and w(u,v)\notin \infty\} & if\,\,\, \exists\, u \\
             \infty & other
             \end{array} 
\right.
\end{equation}
$$

> 特别注意中间那一条：如果已知从 $v_0$ 到 $u$ 的距离（$u\in U$，其最短路径已知），而且存在从 $u$ 到 $v$ 的边，那么从 $v_0$ 到 $v$ 的当前已知距离就是在所有经由满足上述条件的 $u$ 的间接路径中最短的那一条路径的长度



如果在当前所有不属于 $U$ 的顶点中 $v'$ 的 $cdis$ 最小，那么 $dis(v_0,v')=cdis(v_0,v')$，即：从 $v_0$ 到 $v'$ 的当前已知距离就是其实际距离，因此到它的最短路径已知，现在就可以把 $v'$ 加入顶点集合 $U$

> 在构造最短路径的每一步，只需从所有当前还不属于 $U$ 的顶点中选择 $cdis$ 值最小的顶点加入 $U$ 即可



**Dijkstra 算法梗概**

初始：

+ 在集合 $U$ 中放入顶点 $v_0$（$v_0$ 到 $v_0$ 的距离为 $0$）
+ 对 $V-U$ 里的每个顶点 $v$：
  + 如果 $(v_0,v)\in E$（存在直接的边），则到 $v$ 的已知最短路径长度设为 $w(v_0,v)$
  + 否则令 $v$ 的已知最短路径长度为 $\infty$

反复做：

+ 从 $V-U$ 中选出当时已知最短路径长度最小的顶点 $v_{min}$ 加入 $U$

  > 此时到 $v_{min}$ 的已知最短路径长度 $cdis(v_0,v_{min})$ 就是 $v_0$ 到 $v_{min}$ 的距离

+ 由于 $v_{min}$ 的加入，$V-U$ 中某些顶点的已知最短路径可能改变

  > 如果从 $v_0$ 经过 $v_{min}$ 到 $v'$ 的路径比原来已知的最短路径更短，就说明发现了到 $v'$ 的新的已知最短路径
  >
  > > 在这种情况下，更新到 $v'$ 的已知最短路径及距离的记录



如果 $v'$ 是从初始点 $v_0$ 到某顶点 $v$ 的最短路径 $p$ 上 $v$ 的前一顶点，那么从路径 $p$ 去掉最后顶点 $v$ 得到的路径 $p'$ 是$v_0$ 到 $v'$ 的最短路径，即：一条最短路径的前面任何一段都是 $v_0$ 到这段路径终点的最短路径





### 求解任意顶点间最短路径的 $Floyd$（弗洛伊德）算法

$Floyd$ 算法基于图的邻接矩阵表示，所做的基本工作就是求出可达关系的传递闭包，但同时还要记录求出的所有路径及其长度。设 $n$ 个顶点的图 $G=(V,E)$ 的邻接矩阵是 $A$，其中对角线元素的值都是 $0$，表示从各顶点到自身的距离为 $0$，其余元素是权值，无边的情况用 $\infty$ 表示

+ 如果有边 $(v,v')\in E$，那么它自然是从顶点 $v$ 到 $v'$ 的路径，其长度可以由边的权值直接得到，即 $A[v][v']$
+ 从 $v$ 到 $v'$ 的直接路径未必是从 $v$ 到 $v'$ 的最短路径，有可能存在从 $v$ 到 $v'$ 的更短路径，图中经过其他顶点
+ 采用一种系统化的方法，检查和比较从 $v$ 到 $v'$ 的可能经过任何顶点的所有路径，从中找出最短路径



假定图 $G$ 的顶点顺序排列为 $v_0、v_1、\cdots、v_{n-1}$



**开始**

对每对 $v$ 和 $v'$，从 $v$ 到 $v'$ 的图中不经过任何顶点的路径长度已知

+ 如果存在从 $v$ 到 $v'$ 的边，这个长度就是该边的权
+ 无边时认为存在长度为 $\infty$ 的路径



**$k=0$**

对每对 $v$ 和 $v'$，除至此已知的路径外，从 $v$ 到 $v'$ 途径顶点的下标不大于 $k$ （$0$）的路径可分为两段：
$$
<v,v_0>,\,<v_0,v'>
$$
用这一 “新路径” 和前一步已知的路径比较，可以确定从 $v$ 到 $v'$ 途径顶点的下标不大于 $0$ 的最短路径



**$k=1$**

对每对 $v$ 和 $v'$，除至此已知的路径外，从 $v$ 到 $v'$ 途径顶点的下标不大于 $k$（$1$）的路径可分为两段：
$$
<v,\cdots,v_1>,\,<v_1,\cdots,v'>
$$
用这一 “新路径” 与从 $v$ 到 $v'$ 的已知最短路径（途径的顶点下标小于等于 $0$）比较，就可确定从 $v$ 到 $v'$ 的途径顶点的下标小于等于 $1$ 的最短路径



$\cdots$



**一般的 $k$**

对于每对顶点 $v$ 和 $v'$，前面的步骤已经考察了所有从 $v$ 到 $v'$ 的途径顶点的下标小于等于 $k-1$ 的路径，并已获知这些路径中的最短路径及其长度，在这一步，对每对顶点 $v$ 和 $v'$，考虑从 $v$ 到 $v'$ 途径顶点的下标小于等于 $k$ 的所有路径，其中已经考察过的路径的途径顶点的下标都小于等于 $k-1$，尚未考察过的路径都可以分为两段：
$$
<v,\cdots,v_k>,\,<v_k,\cdots,v'>
$$
在这两段路径中途径顶点的下标小于等于 $k-1$，两段的长度在做这一步之前都已经知道，用该路径与已知的从 $v$ 到 $v'$ 的最短路径（途径顶点的下标都小于等于 $k-1$）比较，就可确定从 $v$ 到 $v'$ 途径顶点的下标小于等于 $k$ 的最短路径



如此继续，直到做完 $k=n-1$ 的情况，也就是说，考察完从 $v$ 到 $v'$途径顶点的下标不大于 $n-1$ 的所有路径之后，对每对 $v$ 和 $v'$，已经确定了从 $v$ 到 $v'$的所有可能路径中的最短路径



**算法的实现**

要实现 $Floyd$ 算法过程，需要用递推的方式生成一系列 $n\times n$ 方阵 $A_k(0\leq k\leq n)$

> $A_k[i][j]$ 表示从 $v_i$ 到 $v_j$ 途径顶点可为 $v_0、v_1、\cdots、v_{k-1}$ 的最短路径长度

+ $A_0[i][j]=A[i][j]$，直接由邻接矩阵得到

+ 对一般的 $k$，$A_{k+1}[i][j]=min\{A_k[i][j],\,A_k[i][k]+A_k[k][j]\}$，其中 $0\leq k\leq n-1$

  > $A_{k+1}[i][j]$ 就是从 $v_i$ 到 $v_j$ 途径顶点的下标不大于 $k$ 的最短路径长度

+ 做到最后，$A_n[i][j]$ 为从 $v_i$ 到 $v_j$ 的最短路径长度



算法还需要给出所有最短路径，这里的做法是另计算一系列 $n$ 阶方阵 $N_k$

> $N_k[i][j]$ 的值是从 $v_i$ 到 $v_j$ 的中间可经过顶点 $v_0、\cdots、v_{k-1}$ 的最短路径上，顶点 $v_i$ 的后继顶点 $v_l$ 的下标
>
> 由于从 $v_l$ 到 $v_j$ 的最短路径也有记录，因此可以根据它查找下一个后继顶点，直至得到整个路径

+ 初始时：

  + 如果 $A_0[i][j]=\infty$（没有边），则令 $N_0[i][j]=-1$
  + 否则，令 $N_0[i][j]=j$（表示在 $v_i$ 到 $v_j$ 的路径上 $v_i$ 的后继顶点是 $v_j$）

+ 在由 $v_k$ 计算 $A_{k+1}$ 时，如果 $A_{k+1}[i][j]$ 被设为 $A_k[i][k]+A_k[k][j]$，就设置 $N_{k+1}[i][j]=N_k[i][k]$

  > 表示在 $v_i$ 到 $v_j$ 的路径上 $v_i$ 的后继顶点，就是已知的从 $v_i$ 到 $v_k$ 的路径上 $v_i$ 的后继顶点

  这一轮计算完成后，每个 $N_{k+1}[i][j]$ 都是在从 $v_i$ 到 $v_j$ 的可以途径顶点 $v_0、\cdots、v_{k}$ 的路径上 $v_i$ 的后继顶点

+ 整个计算完成后，$N_n[i][j]$ 就是从 $v_i$ 到 $v_j$ 的最短路径上 $v_i$ 的后继顶点

  > 追溯这个矩阵，可得到任何一对结点之间的最短路径