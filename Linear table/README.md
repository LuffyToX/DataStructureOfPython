# 线性表

一个线性表是某类元素的一个集合，并且记录着元素之间的一种顺序关系

集合 E 上的一个线性表就是 E 中一组有穷个元素排成的序列 L = (e0, e1, ... , en-1 )，其中 ei ∈ E 且 n ≥ 0。在一个表里可以包含 0 个或多个元素，序列中的每个元素在表里有一个确定的位置，称为该元素的下标

一个表中包含的元素的个数称为这个表的长度，显然，空表的长度为 0

表元素之间存在一个基本关系，称为下一个关系。下一个关系是一种顺序关系，即线性表是一种线性结构



不考虑单链表的变形的情况下：

在一个非空的线性表里，存在着唯一的一个首元素和唯一的一个尾元素；

除首元素之外，表中的每个元素 e 都有且仅有一个前驱元素；

除尾元素之外，表中的每个元素 e 都有且仅有一个后继元素

> (e 的) 前驱元素  ==>  e  ==>  (e 的) 后继元素



从实际编程和应用的角度来看，线性表是一种组织数据元素的数据结构：

+ 从实现者的角度：对于一种数据结构有两个问题必须考虑
  1. 如何把该结构内部的数据组织好
  2. 如何提供一套有用而且必要的操作
+ 从使用者的角度：需要考虑该线性表提供了哪些操作，如何有效使用以解决自己的问题

在一个数据结构里，通常需要保存一些信息，需要把这些信息以某种形式存储起来。数据结构的具体表示完全是其内部的东西，在数据结构之外看不到也不应该关心



加入/删除/访问元素的操作效率与表的实现结构有关：

+ 将表中的元素顺序地存放在一大块连续的存储区里  ==>  顺序表
+ 将表元素存放在通过链接构造起来的一系列存储块里  ==>  链表



## 线性表的抽象数据类型：

```python
ADT List:
    List(self)                            # 表构造操作，创建一个新表
    is_empty(self)                        # 判断 self 是否为一个空表
    len_(self)                            # 获得 self 的长度
    prepend(self, elem)                   # 将元素 elem 加入表中作为第一个元素
    append_(self, elem)                   # 将元素 elem 加入表中作为最后一个元素
    insert_(self, elem, i)                # 将元素 elem 加入表中作为第 i 个元素，其它元素顺序不变
    del_first(self)                       # 删除表中的首元素
    del_last(self)                        # 删除表中的尾元素
    del_(self, i)                         # 删除表中第 i 个元素
    search(self, elem)                    # 查找元素 elem 在表中出现的位置，不出现时返回 -1
    forall(self, op)                      # 对表中的每个元素执行 op 操作
```





## 顺序表

顺序表的基本实现方式：表中元素顺序存放在一片足够大的连续存储区中，首元素存入存储区的开始位置，其余元素依次顺序存放。元素之间的逻辑顺序关系通过元素在存储区中的物理位置表示  ==>  隐式表示元素间的关系



设有一个顺序表对象，其元素存储在一片元素存储区中，该存储区的起始位置（内存地址）为 a0：

假定表元素编号从 0 开始，元素 e0 自然应存储在内存位置 Loc(e0) = a0

再假定表中一个元素所需的存储单元数为 c = size(元素)

则元素 ei 的地址计算公式为：Loc(ei) = a0 + c × i

> 存取操作（元素访问）可以在 O(1) 时间内完成



表元素存储块需要安排在计算机内存中，一旦分配就占据了内存的一块区域，有了固定的大小，并因此确定了元素个数的上限。而且，该块的前后都可能被其他有用对象占据，存储块的大小不能随便变化，特别是无法扩充

在一个顺序表的元素存储区中，一般情况是保存着一些元素，还存在一些可以存放元素的空位。在这种情况下，需要约定元素的存放方式，通常把已有元素连续存放在存储区的前面一段，空位都在后面。为了保证正确操作，就需要记录元素存储区的大小  ==> max 和当前的元素个数  ==>  sum



一个顺序表的完整信息包括两部分：

- 表中的元素集合
- 为实现正确操作而需记录的信息，即那些有关表的整体情况的信息  ==>  存储区容量、当前表中的元素个数



两种基本实现方式：

- 一体式结构：存储表信息的单元与元素存储区以连续的方式安排在一块存储区中，几部分数据的整体形成一个完整的表对象

  > Loc(ei) = Loc(L) + C + i × size(e)          C：max 和 num 的存储量

- 分离式结构（动态顺序表）：表对象里只保存与整个表有关的信息  ==>  容量、元素个数，实际元素存放在另一个独立的元素存储区对象中，通过链接与基本表对象关联



分离式结构的最大优点是带来了一种新的可能：可以在标识（id） 不变的情况下，为表对象换一块元素存储区。也就是说，表还是原来的表，其内容可以不变，但是容量改变了

在实际使用中，如果不断向一个顺序表里加入元素，最终一定会填满其元素存储区。如果该表采用一体式结构，此时再向表中加入元素的操作就会失败。由于表对象安排在内存中，它的两边可能有其他对象，一般而言，不可能直接扩大其存储。要想继续程序的工作，就只能另外创建一个容量更大的表对象，把元素搬过去，但这是一个新对象，要修改当时使用原对象的所有位置，使之改用新对象，这个任务通常很难完成

如果采用分离式结构，问题就很容易解决了。这时可以在不改变对象的情况下换一块更大的元素存储区：

1. 另外申请一块更大的元素存储区
2. 把表中已有的元素复制到新存储区
3. 用新的元素存储区替换原来的元素存储区  ==>  改变表对象的元素区链接
4. 实际加入新元素



## Python 的 list

Python 的 list 和 tuple 采用了顺序表的实现技术，具有顺序表的所有性质

> tuple 是不变的表，因此不支持改变其内部状态的任何操作，在其它方面，与 list 类似



Python 的 list 的主要约束  ==>  分离式结构的顺序表：

- 元素可变
- 保序
- 基于下标的高效元素访问和更新  ==>  O(1)
- 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（id）不变



在 Python 的官方系统中，list 的实现采用了如下策略：创建空表时不分配元素存储区。遇到 insert() / append() 添加元素时，系统第一次分配能容纳 4 个元素的存储区。继续扩容时采用的策略是每次扩容的比率趋近 1.125



list 的主要操作的时间复杂度：

- len()  ==>  O(1)  ==>  表中必须记录元素个数（num），自然可以简单的采用
- 元素访问、赋值、尾端加入、尾端删除  ==>  O(1)
- 一般位置的加入、切片替换、切片删除、表拼接（extend()）==>  O(n)



Python 的一个问题是：没有提供检查一个 list 对象的当前存储块容量的操作，也没有设置容量的操作

> 一切与容量有关的处理都由 Python 解释器自动完成



顺序表：

- 最大的优点：定位元素的时间复杂度是 O(1)
- 最大得到缺点：加入 / 删除 的时间复杂度大部分为 O(n)，只有尾插 / 尾删 是 O(1)